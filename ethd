#!/usr/bin/env bash
#set -euo pipefail
set -uo pipefail

__docker_exe="docker"
__compose_exe="docker-compose"

dodocker() {
    $__docker_exe "$@"
}

docompose() {
    $__compose_exe "$@"
}

determine_distro() {
    # Determine OS platform
    __uname=$(uname | tr "[:upper:]" "[:lower:]")
    # If Linux, try to determine specific distribution
    if [ "$__uname" == "linux" ]; then
        # If available, use LSB to identify distribution
        if [ -n "$(which lsb_release 2>/dev/null)" ]; then
            __distro=$(lsb_release -i | cut -d: -f2 | sed s/'^\t'//)
        # Otherwise, use release info file
        else
            __distro=$(ls -d /etc/[A-Za-z]*[_-][rv]e[lr]* | grep -v "lsb" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1)
        fi
    else
        __distro=""
    fi
    # For everything else (or if above failed), just use generic identifier
    [ "$__distro" == "" ] && __distro=$__uname
    unset __uname
    __distro=$(echo $__distro | tr "[:upper:]" "[:lower:]")
}

determine_sudo() {
    __maybe_sudo=""
    if ! docker images >/dev/null 2>&1; then
        echo "Will use sudo to access docker"
        __maybe_sudo="sudo"
    fi
}

determine_docker() {
    if [ -n "$__maybe_sudo" ]; then
        __docker_exe="sudo $__docker_exe"
    fi
}

determine_compose() {
# This is mainly for Debian and docker-ce, where docker-compose does not exist
  type -P docker-compose >/dev/null 2>&1
  if [ $? -ne 0 ]; then
    __compose_exe="docker compose"
  else
    __compose_version=$($__maybe_sudo docker-compose --version | sed -n -e "s/.*version [v]\?\([0-9.-]*\).*/\1/p")
    __compose_version_major=$(echo $__compose_version | cut -f1 -d.)
    __compose_version_minor=$(echo $__compose_version | cut -f2 -d.)
    if ! [ "$__compose_version_major" -eq "$__compose_version_major" -a "$__compose_version_minor" -eq "$__compose_version_minor" ] 2> /dev/null; then
        echo "docker-compose version detection failed. Please report this output so it can be fixed."
        $__maybe_sudo docker-compose --version
    elif [ "$__compose_version_major" -eq 1 -a "$__compose_version_minor" -lt 28 ]; then
      echo "Error: Outdated docker-compose version detected ($__compose_version). Please upgrade to version 1.28.0 or later." >&2
      if [[ "$__distro" = "ubuntu" ]]; then
        __major_version=$(lsb_release -r | cut -d: -f2 | sed s/'^\t'// | cut -d. -f1)
        if [ ${__major_version} -lt 22 ]; then
          echo
          while true; do
            read -rp "Do you want to update docker-compose to v1.29.2? (yes/no) " yn
            case $yn in
              [Nn]* ) echo "Please be sure to update docker-compose yourself!"; exit 1;;
              * ) upgrade_compose; break;;
            esac
          done
        fi
      else
        echo >&2
        echo "On Debian 11, using docker-ce instead of docker.io, with the compose plugin, will work." >&2
        exit 1
      fi
    fi
    __compose_exe="docker-compose"
  fi

  if [ -n "$__maybe_sudo" ]; then
    __compose_exe="sudo $__compose_exe"
  fi
}

upgrade_compose() {
  type -P docker-compose >/dev/null 2>&1
  if [ $? -eq 0 ]; then
    __compose_version=$($__maybe_sudo docker-compose --version | sed -n -e "s/.*version \([0-9.-]*\).*/\1/p")
    __compose_version_major=$(echo $__compose_version | cut -f1 -d.)
    __compose_version_minor=$(echo $__compose_version | cut -f2 -d.)
    if [ "$__compose_version_major" -eq 1 -a "$__compose_version_minor" -lt 28 ]; then
      echo "Found docker-compose version $__compose_version_major.$__compose_version_minor, upgrading to 1.29.2"
      ${__auto_sudo} apt-get install -y curl
      ${__auto_sudo} curl -fsSL "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/bin/docker-compose
      ${__auto_sudo} chmod +x /usr/bin/docker-compose
    fi
    __compose_version=$($__maybe_sudo docker-compose --version | sed -n -e "s/.*version \([0-9.-]*\).*/\1/p")
    __compose_version_major=$(echo $__compose_version | cut -f1 -d.)
    __compose_version_minor=$(echo $__compose_version | cut -f2 -d.)
    if [ "$__compose_version_major" -eq 1 -a "$__compose_version_minor" -lt 28 ]; then
      echo "Updating docker-compose failed. It is still version $__compose_version_major.$__compose_version_minor."
      echo "Please manually update docker-compose to version 1.29.2. These commands should do it:"
      echo "sudo curl -fsSL "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/bin/docker-compose"
      echo "sudo chmod +x /usr/bin/docker-compose"
      exit 1
    fi
  fi
}

handle_root() {
    if [ "${EUID}" -eq 0 ]; then
        __as_owner="sudo -u ${OWNER}"
        __auto_sudo=""
    else
        __as_owner=""
        __auto_sudo="sudo"
    fi
}

check_for_snap() {
    if [[ "$__distro" = "ubuntu" && -n "$(which snap)" && -n "$(snap list 2>/dev/null | grep -w 'docker')" ]]; then
        echo
        echo "WARNING! Snap docker package detected. This WILL result in issues."
        echo "Removing the package will delete volumes and require a resync,"
        echo "as well as re-import of all validator keys."
        echo
        echo "Doing so is still highly recommended however."
        echo
        echo "The exact steps depend a little on whether there already is"
        echo "an apt version of docker installed as well, but in a nutshell"
        echo '"./ethd stop" followed by "sudo snap remove --purge docker"'
        echo "and then a reboot, and as needed install docker.io or docker-ce with apt,"
        echo "re-import keys and restart eth-docker."
        echo
        echo "Do join us on EthStaker Discord to work through this issue."
        echo
        echo "Aborting, this is not safe"
        exit 1
    fi
}

install() {
    check_for_snap
    while true; do
        read -rp "This will attempt to install docker and make your user part of the docker group. Do you wish to continue? (no/yes) " yn
        case $yn in
            [Yy]* ) break;;
            * ) echo "Aborting, no changes made"; exit 0;;
        esac
    done
    if [[ "$__distro" = "ubuntu" ]]; then
        __major_version=$(lsb_release -r | cut -d: -f2 | sed s/'^\t'// | cut -d. -f1)
        if [ ${__major_version} -lt 20 ]; then
            echo "This script cannot install docker on Ubuntu ${__major_version}. Consider upgrading to 22.04 or 20.04"
        fi
        if [ -z "$(which docker)" ]; then
            ${__auto_sudo} apt-get update && ${__auto_sudo} apt-get install -y --install-recommends docker-compose whiptail
            ${__auto_sudo} systemctl enable docker
            echo "Installed docker.io and docker-compose"
        else
            echo "Docker is already installed"
        fi
        if [ ${__major_version} -lt 22 ]; then
            upgrade_compose
        fi
        __groups=$(${__as_owner} groups)
        if [[ ! "$__groups" =~ "docker" ]]; then
            echo "Making your user part of the docker group"
            ${__auto_sudo} usermod -aG docker ${OWNER}
            echo "Please run newgrp docker or log out and back in"
        else
            echo "Your user is already part of the docker group"
        fi
    elif [[ "$__distro" =~ "debian" ]]; then
        if [ -z "$(which docker)" ]; then
            ${__auto_sudo} apt-get update
            ${__auto_sudo} apt-get -y install ca-certificates curl gnupg lsb-release
            ${__auto_sudo} mkdir -p /etc/apt/keyrings
            ${__auto_sudo} curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
            ${__auto_sudo} echo \
                "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
                $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            ${__auto_sudo} apt-get update
            ${__auto_sudo} apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            echo "Installed docker-ce and docker-compose-plugin"
        else
            echo "Docker is already installed"
        fi
    else
        echo "This script cannot install docker on $__distro"
    fi
    return 0
}

update() {
    if [ -z "${ETHDSECUNDO-}" ]; then
        if ${__as_owner} git branch | grep -q master; then
            ${__as_owner} git branch -m master main
            ${__as_owner} git fetch origin
            ${__as_owner} git branch -u origin/main main
            ${__as_owner} git remote set-head origin -a
        fi
        # Do not track changes to ext-network.yml
        ${__as_owner} git update-index --assume-unchanged ext-network.yml
        ${__as_owner} git config pull.rebase false
        ${__as_owner} git pull
        # BASH_SOURCE so newer code gets to do the update. Use an ENV var
        # to avoid infinite loop
        export ETHDSECUNDO=1
        exec "${BASH_SOURCE}" update $@
    fi

    __keeptargets=0
    __targetcli=""
    while :
    do
        if [ -z ${1+x} ]; then
            break
        fi
        case "$1" in
            --keep-targets)
                __keeptargets=1
                __targetcli="--keep-targets"
                shift
                ;;
            *)
                echo "Error: Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    envmigrate

    if [ "${__switched_branch-}" -eq 1 ]; then
        # This code has changed, run it again on the new branch
        export ETHDSECUNDO=1 #Not strictly necessary but this way we don't rely on what happens earlier
        export ETHDSWITCHED=1
        exec "${BASH_SOURCE}" update $__targetcli
    fi

    docompose build --pull
    docompose --profile tools build --pull
    exec 3>&1
    exec 4>&2
    exec 1> /dev/null
    exec 2> /dev/null
    docompose pull || true
    exec 1>&3
    exec 2>&4

    echo
    cmp -s "${ENV_FILE}" "${ENV_FILE}".bak
    if [ $? -ne 0 ]; then
        echo "List of changes made to ${ENV_FILE} during migration - current on left, original on right:"
        echo
        diff -y --suppress-common-lines "${ENV_FILE}" "${ENV_FILE}".bak
	echo
        if [ $__pre_merge -eq 1 ]; then
            echo "You appear to be coming from a pre-merge setup."
            echo "A copy of your original settings is in .env.premerge"
            echo
            echo "Pay special attention to EL_NODE, as failover is no longer supported."
	    echo
	    echo "Decide whether to use mev-boost. Please see MEV_BOOST in .env for details."
        fi
    else
        echo "No changes made to ${ENV_FILE} during migration"
    fi
    if [ $__el_infura -eq 1 ]; then
        echo
        echo "Detected use of an Infura project as an EL or failover EL. This is no longer supported with merge."
        echo "Please adjust your EL_NODE variable manually."
    fi
    if [ $__el_adjusted -eq 1 ]; then
        echo
        echo "Your EL_NODE variable has been adjusted to use the new Engine API port"
    elif [ $__pre_merge -eq 1 ]; then
        echo
        echo "Your EL_NODE variable has not been adjusted to use the new Engine API port, as you had a non-standard value."
        echo "Please take a look and adjust manually."
    fi
    echo
    echo "Your ${ENV_FILE} configuration settings have been migrated to a fresh copy. You can \
find the original contents in ${ENV_FILE}.bak."
    if [ $__keeptargets = "0" ]; then
      echo "NB: If you made changes to the source or binary build targets, these have NOT \
been migrated, please recreate these changes yourself."
    fi
    echo
    echo "An ./ethd up command will start using the new images and configuration."
    if [[ "$__distro" = "ubuntu" ]]; then
      __major_version=$(lsb_release -r | cut -d: -f2 | sed s/'^\t'// | cut -d. -f1)
      if [ ${__major_version} -lt 20 ]; then
         echo
         echo "Ubuntu ${__major_version} is older than the recommended 22.04 or 20.04 version"
         echo
      fi
    fi

    unset ETHDSECUNDO
    if [[ ${ETHDSWITCHED-} -eq 1 ]]; then
        unset ETHDSWITCHED
        echo
        echo "You were migrated to the $(${__as_owner} git name-rev --name-only HEAD) branch of eth-docker"
        echo
    fi
    delete_erigon
    # If this is called by an older version of ethd, envmigrate
    # is in its own bash instance: Need to kill the ethd parent
    if ps $PPID | grep -q "ethd"; then
        echo
        echo "Updated from an older version of eth-docker. You'll see \"Terminated\","
        echo "which keeps the update from running twice. This is normal and will"
        echo "only happen this once."
        echo
        kill $PPID
    fi
    check_for_snap
}

envmigrate() {
    if [ -z "${ETHDSECUNDO-}" ]; then
        # We'd only ever hit this if called from an older version of ethd, so let's
        # get the new version executed.
        export ETHDSECUNDO=1
        # Account for different ways that envmigrate was called in older code and
        # set keep-targets correctly regardless
        if [ -z "${KEEPTARGETS-}" ]; then
            __keep=""
            for var in "$@"; do
                if [ "$var" = "--keep-targets" ]; then
                    __keep="--keep-targets"
                fi
            done
        else
            __keep=""
            if [ ${KEEPTARGETS-} -eq 1 ]; then
                __keep="--keep-targets"
            fi
        fi
        exec "${BASH_SOURCE}" update ${__keep}
    fi

    if [ ! -f "./${ENV_FILE}" ]; then
        return
    fi

    ALL_VARS=( COMPOSE_FILE FEE_RECIPIENT EL_NODE GRAFFITI NETWORK MEV_BOOST MEV_RELAYS MEV_NODE OVERRIDE_TTD \
            CL_MAX_PEER_COUNT CL_MIN_PEER_COUNT EL_MAX_PEER_COUNT EL_MIN_PEER_COUNT DOMAIN ACME_EMAIL \
            CF_EMAIL CF_API_TOKEN AWS_PROFILE AWS_HOSTED_ZONE_ID GRAFANA_HOST DISTRIBUTED \
            PROM_HOST HOST_IP PRYSM_HOST EE_HOST EL_HOST EL_LB EL_WS_HOST EL_WS_LB CL_HOST CL_LB DDNS_SUBDOMAIN DDNS_PROXY RAPID_SYNC_URL \
            CL_NODE BEACON_STATS_API BEACON_STATS_MACHINE EL_P2P_PORT CL_P2P_PORT PRYSM_PORT DOPPELGANGER \
            PRYSM_UDP_PORT GRAFANA_PORT KEY_API_PORT TRAEFIK_WEB_PORT TRAEFIK_WEB_HTTP_PORT CL_REST_PORT \
            EL_RPC_PORT EL_WS_PORT EE_PORT ERIGON_TORRENT_PORT LOG_LEVEL JWT_SECRET GETH_CACHE SSV_P2P_PORT SSV_P2P_PORT_UDP )
    TARGET_VARS=( NIM_SRC_BUILD_TARGET NIM_DOCKER_TAG NIM_DOCKERFILE TEKU_SRC_BUILD_TARGET TEKU_DOCKER_TAG \
                TEKU_DOCKERFILE LH_SRC_BUILD_TARGET LH_DOCKER_TAG LH_DOCKERFILE PRYSM_SRC_BUILD_TARGET \
                PRYSM_DOCKER_TAG PRYSM_DOCKERFILE ERIGON_SRC_BUILD_TARGET ERIGON_DOCKER_TAG ERIGON_DOCKERFILE \
                AKULA_SRC_BUILD_TARGET AKULA_DOCKER_TAG AKULA_DOCKERFILE MEV_DOCKERFILE MEV_DOCKER_TAG \
                LS_SRC_BUILD_TARGET LS_DOCKER_TAG LS_DOCKERFILE GETH_SRC_BUILD_TARGET GETH_DOCKER_TAG \
                GETH_DOCKERFILE NM_SRC_BUILD_TARGET NM_DOCKER_TAG NM_DOCKERFILE BESU_SRC_BUILD_TARGET \
                BESU_DOCKER_TAG BESU_DOCKERFILE SSV_NODE_TAG SSV2_NODE_TAG DEPCLI_SRC_BUILD_TARGET DEPCLI_DOCKER_TAG \
                NODE_EXPORTER_IGNORE_MOUNT_REGEX )
    OLD_VARS=( LH_PORT PRYSM_WEB_PORT EC_NODE REWARDS_TO \
            EC_HOST EC_LB EC_WS_HOST EC_WS_LB CC_HOST CC_LB EC_P2P_PORT CC_NODE CC_P2P_PORT EC_RPC_PORT EC_WS_PORT )
    NEW_VARS=( CL_P2P_PORT KEY_API_PORT EL_NODE FEE_RECIPIENT \
            EL_HOST EL_LB EL_WS_HOST EL_WS_LB CL_HOST CL_LB EL_P2P_PORT CL_NODE CL_P2P_PORT EL_RPC_PORT EL_WS_PORT )

    if [ "${EUID}" -eq 0 ]; then
      # Previous version of this tool when run as root may have created a root-owned .env.bak
      if [ -f ./"${ENV_FILE}".bak ]; then
          rm "${ENV_FILE}".bak
      fi
      sudo -u "${OWNER}" cp "${ENV_FILE}" "${ENV_FILE}".bak
      sudo -u "${OWNER}" cp default.env "${ENV_FILE}"
      sudo -u "${OWNER}" cp "${ENV_FILE}".bak .env.source
    else
      cp "${ENV_FILE}" "${ENV_FILE}".bak
      cp default.env "${ENV_FILE}"
      cp "${ENV_FILE}".bak .env.source
    fi
    # Detect pre-merge
    if grep -q "FALLBACK_NODE1" ".env.source"; then
      __pre_merge=1
      cp .env.source .env.premerge
    else
      __pre_merge=0
    fi
    # Migrate over user settings
    for var in "${ALL_VARS[@]}"; do
        #value=$(grep --color=never -Po "^${var}=\K.*" ".env.source" || true)
        value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env.source" || true)
        if [ -n "${value}" -o "${var}" = "GRAFFITI" ]; then
            if [ "${var}" = "COMPOSE_FILE" ]; then
                migrate_compose_file
            fi
            if [[ "${var}" = "NETWORK" && "${value}" =~ "prater" ]]; then
                value="goerli"
            fi
            sed -i'.original' -e "s~^\(${var}\s*=\s*\).*$~\1${value}~" "${ENV_FILE}"
        fi
    done
    if [ $__keeptargets = "1" ]; then
      # Migrate over build targets
      for var in "${TARGET_VARS[@]}"; do
          #value=$(grep --color=never -Po "^${var}=\K.*" ".env.source" || true)
          value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env.source" || true)
          if [ -n "${value}" ]; then
              sed -i'.original' -e "s~^\(${var}\s*=\s*\).*$~\1${value}~" "${ENV_FILE}"
          fi
      done
    fi
    # Move value from old variable name(s) to new one(s)
    for index in "${!OLD_VARS[@]}"; do
        var=${OLD_VARS[index]}
        #value=$(grep --color=never -Po "^${var}=\K.*" ".env.source" || true)
        value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env.source" || true)
        if [ -n "${value}" ]; then
            sed -i'.original' -e "s~^\(${NEW_VARS[index]}\s*=\s*\).*$~\1${value}~" "${ENV_FILE}"
        fi
    done
    # Check whether we run a CL or VC, if so nag about FEE_RECIPIENT
    var="COMPOSE_FILE"
    #value=$(grep --color=never -Po "^${var}=\K.*" ".env" || true)
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    # It's CL&VC, CL-only, or VC-only
    if [[ "${value}" =~ "-base.yml" || "${value}" =~ "-cl-only.yml" || "${value}" =~ "-vc-only.yml" ]]; then
        # Check for rewards
        var="FEE_RECIPIENT"
        #value=$(grep --color=never -Po "^${var}=\K.*" ".env" || true)
        value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
        if [[ -z "${value}" || ${value} != 0x* || ${#value} -ne 42 ]]; then
            whiptail --msgbox "A fee recipient ETH wallet address is required in order to start the client. This is for post-merge priority fees and, optionally, MEV. Please enter a valid ETH address in the next screen. Refer to eth-docker docs (https://eth-docker.net/docs/About/Rewards) for more information.\n\nCAUTION: \"./ethd up\" will fail if no valid address is set" 16 75
            __during_update=1
            query_coinbase
            set_value_in_env
        fi
    fi
    # Check for Blox SSV 1 and offer migration
    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if [[ "${value}" =~ "blox-ssv.yml" ]]; then
        query_blox_switch
    fi

    # User signals it's a distributed setup and not to nag
    # Ditto do not nag if we switched branch, as the code that does
    # the check won't be accurate
    var="DISTRIBUTED"
    #value=$(grep --color=never -Po "^${var}=\K.*" ".env" || true)
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if [[ "${value}" = "true" || "${__switched_branch-}" -eq 1 ]]; then
        rm .env.source
        rm .env.original
        return
    fi
    # Check for CL and EL, nag if we have only one without the other
    var="COMPOSE_FILE"
    #value=$(grep --color=never -Po "^${var}=\K.*" ".env" || true)
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    # Case 1 ... CL, do we have an EL?
    if [[ "${value}" =~ "-base.yml" || "${value}" =~ "-cl-only.yml" ]]; then
        if [[ ! "${value}" =~ "geth.yml" && ! "${value}" =~ "besu.yml" && ! "${value}" =~ "erigon.yml" && ! "${value}" =~ "nethermind.yml" && ! "${value}" =~ "akula.yml" ]]; then
            whiptail --msgbox "An Execution Layer client is required alongside your Consensus Layer client come Ethereum Merge. Refer to eth-docker docs (https://eth-docker.net/docs/About/MergePrep) for more information.\n\nPlease start running your own EL soonest, as Infura will no longer be usable as an EL after The Merge.\n\nIf you run a distributed setup, you can shut off this nag screen by setting DISTRIBUTED=true in .env" 16 75
        fi
    # Case 2 ... EL, do we have a CL?
    elif [[ "${value}" =~ "geth.yml" || "${value}" =~ "besu.yml" || "${value}" =~ "erigon.yml" || "${value}" =~ "nethermind.yml" || "${value}" =~ "akula.yml" ]]; then
        if [[ ! "${value}" =~ "-base.yml"  && ! "${value}" =~ "-cl-only.yml" ]]; then
            whiptail --msgbox "A Consensus Layer client is required alongside your Execution Layer client come Ethereum Merge. Refer to eth-docker docs (https://eth-docker.net/docs/About/MergePrep) for more information.\n\nPlease start running your own CL soonest, as an EL alone will no longer be usable after The Merge.\n\nIf you run a distributed setup, you can shut off this nag screen by setting DISTRIBUTED=true in .env" 16 75
        fi
    fi
    # Adjust EL_NODE as needed
    __el_adjusted=0
    __el_infura=0
    var="EL_NODE"
    #value=$(grep --color=never -Po "^${var}=\K.*" ".env" || true)
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if [[ "${value}" =~ "infura.io" ]]; then
       __el_infura=1
    fi
    if [[ "${value}" =~ "http://execution:8545" ]]; then
       EL_NODE="http://execution:8551"
       set_value_in_env
       __el_adjusted=1
    elif [[ "${value}" =~ "ws://execution:8546" || "${value}" =~ "ws://execution:8545" ]]; then
       EL_NODE="ws://execution:8551"
       set_value_in_env
       __el_adjusted=1
    fi
    rm .env.source
    rm .env.original
}

migrate_compose_file() {
# When this gets called $var is COMPOSE_FILE and $value is what is set in .env for it
# Some files have been renamed and others removed altogether
    FROM_YML=( ec-shared.yml ec-traefik.yml cc-shared.yml grafana-insecure.yml prysm-web-insecure.yml lh-base-notz.yml lh-validator-notz.yml lh-slasher.yml teku-base-notz.yml teku-validator-notz.yml lh-consensus.yml lh-validator.yml lodestar-consensus.yml lodestar-validator.yml nimbus-consensus.yml prysm-consensus.yml prysm-consensus-rest.yml prysm-validator.yml teku-consensus.yml teku-validator.yml lh-base.yml lh-vc-only.yml lh-cl-only.yml nm.yml prysm-web.yml blank-grafana.yml lh-grafana.yml lhcc-grafana.yml nimbus-grafana.yml prysm-grafana.yml teku-grafana.yml geth-grafana.yml erigon-grafana.yml oe.yml teku-stats.yml lh-stats.yml lh-stats-consensus.yml lh-stats-validator.yml traefik-shared.yml )
    TO_YML=( el-shared.yml el-traefik.yml cl-shared.yml grafana-shared.yml prysm-web-shared.yml lighthouse-base.yml lighthouse-vc-only.yml lighthouse-slasher.yml teku-base.yml teku-vc-only.yml lighthouse-cl-only.yml lighthouse-vc-only.yml lodestar-cl-only.yml lodestar-vc-only.yml nimbus-cl-only.yml prysm-cl-only.yml prysm-cl-only.yml prysm-vc-only.yml teku-cl-only.yml teku-vc-only.yml lighthouse-base.yml lighthouse-vc-only.yml lighthouse-cl-only.yml nethermind.yml "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" )

    __old_grafana=0
    __new_grafana=0
    __grafana_regex=".+-grafana\.yml"
    __switched_branch=0
    __old_ifs="$IFS"
    IFS=":"
    set -o noglob
    __ymlarray=($value) # split+glob with glob disabled, and split using : as delimiter
    set +o noglob
    IFS="$__old_ifs"

    value=""
    for n in "${!__ymlarray[@]}"; do
        __ymlfile="${__ymlarray[n]}"
        if [[ "${__ymlfile}" =~ $__grafana_regex ]]; then
            __old_grafana=1
        fi
        if [ "${__ymlfile}" = "grafana.yml" ]; then
            __new_grafana=1
        fi
        for index in "${!FROM_YML[@]}"; do
            if [ "${FROM_YML[index]}" = "${__ymlfile}" ]; then
                __ymlfile=${TO_YML[index]}
                break
            fi
        done
        if [ -n "${__ymlfile}" ]; then
            if [ -z "${value}" ]; then
                value="${__ymlfile}"
            else
                value="${value}:${__ymlfile}"
            fi
        fi
    done
    if [ "${__new_grafana}" = 0 -a "${__old_grafana}" = 1 ]; then
        value="${value}:grafana.yml"
    fi
}

delete_erigon() {
    # Check for Erigon
    var="COMPOSE_FILE"
    #value=$(grep --color=never -Po "^${var}=\K.*" ".env" || true)
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if [[ ! "${value}" =~ "erigon.yml" ]]; then
        return
    fi

    if [ -z "$(dodocker volume ls -q | grep $(basename $(realpath .))_erigon-ec-data)" ]; then
        return
    fi

    echo "Detected Erigon. For merge, it will need to be re-synced from scratch"
    echo
    while true; do
        read -rp "WARNING - About to delete the Erigon database. Do you wish to continue? (Y/n) " yn
        case $yn in
            [Nn]o | [Nn]  ) echo "Aborting, no changes made"; exit 1;;
            * ) break;;
        esac
    done

    echo "Stopping Erigon container"
    dodocker stop $(basename $(realpath .))_erigon_1 && dodocker rm -f $(basename $(realpath .))_erigon_1
    docompose stop execution && docompose rm -f execution
    dodocker volume rm $(dodocker volume ls -q | grep $(basename $(realpath .))_erigon-ec-data)
    echo ""
    echo "Erigon stopped and database deleted."
    echo ""
}

query_blox_switch() {
    echo "Detected SSV Node v1. SSV v2 testnet is the new hotness."
    echo
    while true; do
        read -rp "Do you wish to switch to SSV v2? (Y/n) " yn
        case $yn in
            [Nn]o | [Nn]  ) echo "No changes made"; return;;
            * ) break;;
        esac
    done
    echo "Stopping SSV Node container"
    docker stop $(basename $(realpath .))_ssv-node_1 && docker rm -f $(basename $(realpath .))_ssv-node_1
    docompose stop ssv-node && docompose rm -f ssv-node
    docker volume rm $(docker volume ls -q | grep $(basename $(realpath .))_ssv-data)
    echo ""
    echo "SSV Node stopped and database deleted."
    echo ""
    cp blox-ssv-config.yaml blox-ssv-config.yaml.bak
    echo "Backup copy blox-ssv-config.yaml.bak created"
    echo "Making changes to blox-ssv-config.yaml"
    sed -i 's/blox-ssv.yml/blox-ssv2.yml/' .env
    sed -i '/RegistryContractAddr/d' blox-ssv-config.yaml
    sed -i '/RegistryContractABI/d' blox-ssv-config.yaml
    sed -i '/ETH1SyncOffset/d' blox-ssv-config.yaml
    sed -i '/AbiVersion/d' blox-ssv-config.yaml
    sed -i '/Bootnodes/d' blox-ssv-config.yaml
    sed -i '/NetworkID/d' blox-ssv-config.yaml
}

prune-geth() {
    __non_interactive=0
    while :
    do
        if [ -z ${1+x} ]; then
            break
        fi
        case "$1" in
            --non-interactive)
                __non_interactive=1
                shift
                ;;
            *)
                echo "Error: Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    if [ ! -f "./${ENV_FILE}" ]; then
        echo "${ENV_FILE} configuration file not found, aborting."
        exit 1
    fi

    if ! grep -q '^COMPOSE_FILE=.*geth\.yml' "${ENV_FILE}" 2>/dev/null ; then
        echo "You do not appear to be using Geth, aborting."
        exit 1
    fi

    if [ $(df -P /var/lib/docker | awk '/[0-9]%/{print $(NF-2)}') -lt 41943040 ]; then
        echo "You do not have enough free disk space. Make sure this reads at least 40G free (Avail):"
        df -h /var/lib/docker
        echo ""
        echo "Aborting."
        exit 1
    fi

    rpc_line=$(grep '^EL_RPC_PORT=' "${ENV_FILE}")
    regex='^EL_RPC_PORT=([0-9]+)'
    if [[ ! "${rpc_line}" =~ ${regex} ]]; then
        echo "Unable to determine EL_RPC_PORT, aborting."
        exit 1
    else
        rpc_port="${BASH_REMATCH[1]}"
    fi

    sync_status=$(docompose exec -T execution wget -qO- "http://localhost:$rpc_port" --header 'Content-Type: application/json' --post-data '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}')
    exitstatus=$?
    if [ $exitstatus -ne 0 ]; then
        echo "Unable to connect to Geth: Is it running? Aborting."
        exit 1
    fi

    if [[ ! "${sync_status}" =~ "false" ]]; then
        echo "Geth is not done syncing yet. Sync status:"
        echo "${sync_status}"
        echo ""
        echo "Aborting."
        exit 1
    fi

    node_logs=$(docompose logs --no-color --tail 1000 execution)
    if [[ "${node_logs}" =~ "snapshot generation" && ! "${node_logs}" =~ "Generated state" ]]; then
        echo "Geth has not finished generating a state snapshot yet, aborting."
        exit 1
    fi

    regex='\[([0-9][0-9]-[0-9][0-9])\|([0-9][0-9]:[0-9][0-9]):[0-9.]*\][[:space:]]*Generated state'
    if [[ "${node_logs}" =~ $regex ]]; then
        snap_time=$(date -d "1970-${BASH_REMATCH[1]} ${BASH_REMATCH[2]}" +"%s")
        now_time=$(date +"%s")
        if [ $(($snap_time+2100)) -gt $now_time ]; then
            echo "Please wait 35 minutes after snapshot generation finished. Aborting."
            exit 1
        fi
    fi

    if [ $__non_interactive = 0 ]; then
      while true; do
          read -rp "WARNING - this will stop Geth and prune its database. Do you wish to continue? (No/Yes) " yn
          case $yn in
              [Yy]es ) break;;
              * ) echo "Aborting, no changes made"; exit 1;;
          esac
      done
    fi

    echo ""
    echo "Starting Geth prune"
    echo ""
    docompose run --rm set-prune-marker "touch /var/lib/goethereum/prune-marker"
    docompose stop execution && docompose rm -f execution
    start
    echo ""
    echo "Prune is running, you can observe it with 'sudo ./ethd logs -f execution'"
    echo ""
    echo "There should be three stages: \"Iterating state snapshot\", \"Pruning state data\", and \"Compacting database\". During \
the \"Compacting database\" stage it may not output logs for an hour or so, that is normal."
    echo ""
    echo "When prune is done, which takes 4-5 hours, Geth will automatically start again."
    echo "NB: 'sudo' can be left off the './ethd logs' command if your user is part of the 'docker' group."
    echo ""
}

prep-keyimport() {
    set -Eeuo pipefail
    if [ ! -f "./${ENV_FILE}" ]; then
        echo "${ENV_FILE} configuration file not found, aborting."
        exit 1
    fi
    if grep -q '^COMPOSE_FILE=.*cl-only\.yml' "${ENV_FILE}" 2>/dev/null ; then
        echo "eth-docker is configured to run consensus client only, key import not possible"
        exit 1
    fi

    __prysm=0
    __path=''
    __non_interactive=0
    if grep -q '^COMPOSE_FILE=.*prysm.*\.yml' "${ENV_FILE}" 2>/dev/null ; then
        __prysm=1
    fi

    while :
    do
        if [ -z ${1+x} ]; then
            break
        fi
        case "$1" in
            --path)
                if [ -z ${2+x} ]; then
                    echo "--path requires a directory path, aborting"
                    exit 1
                fi
                if [ ! -d $2 ]; then
                    echo "$2 is not a directory"
                    exit 1
                fi
                if [ $(realpath "$2") = $(realpath ".eth/validator_keys") ]; then
                    echo "$2 is the default path, doing nothing special"
                    shift 2
                    continue
                fi
                IFS=$'\n'
                files=$(find $2 -maxdepth 1 -name '*.json')
                unset IFS
                if [ -z "$files" ]; then
                    echo "No .json files found in $2, aborting"
                    exit 1
                fi
                IFS=$'\n'
                files=$(find ./.eth/validator_keys -maxdepth 1 -name '*.json')
                unset IFS
                if [ -n "$files" ]; then
                    mkdir -p ./.eth/validator_keys/keybackup
                    mv -uf ./.eth/validator_keys/*.json ./.eth/validator_keys/keybackup
                    rm -f ./.eth/validator_keys/*.json
                    echo "Moved existing json files to .eth/validator_keys/keybackup"
                fi
                cp $2/*.json .eth/validator_keys/
                shift 2
                ;;
            --non-interactive)
                if [ -z ${KEYSTORE_PASSWORD+x} ]; then
                    echo "KEYSTORE_PASSWORD not set, aborting"
                    exit 1
                fi
                if [ ${__oldskool:-} = 1 -a ${__prysm} = 1 ]; then
                    if [ -z ${WALLET_PASSWORD+x} ]; then
                        echo "Using Prysm and WALLET_PASSWORD not set, aborting"
                        exit 1
                    fi
                fi
                __non_interactive=1
                shift
                ;;
            *)
                echo "Error: Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done
}

keyimport() {
    __oldskool=1
    prep-keyimport "$@"
    if [ ${__non_interactive} = 1 ]; then
        docompose run --rm validator-import --non-interactive
    else
        docompose run --rm validator-import
    fi
}

keys() {
    __oldskool=0
    if [ "${1:-}" = "import" ]; then
        shift
        prep-keyimport "$@"
        if [ ${__non_interactive} = 1 ]; then
            docompose run --rm validator-keys import --non-interactive
        else
            docompose run --rm validator-keys import
        fi
    else
        docompose run --rm validator-keys "$@"
    fi
}

upgrade() {
  update
}

start() {
    docompose up -d --remove-orphans
}

up() {
    start
}

run() {
    start
}

stop() {
    docompose down --remove-orphans
}

down() {
    stop
}

terminate() {
    while true; do
        read -rp "WARNING - this action will destroy all data stores for this Ethereum node. Do you wish to continue? (No/Yes) " yn
        case $yn in
            [Yy]es ) break;;
            * ) echo "Aborting, no changes made"; exit 1;;
        esac
    done

    down
    dodocker volume rm $(dodocker volume ls -q | grep $(basename $(realpath .)))
    echo ""
    echo "All containers stopped and all volumes deleted"
    echo ""
}

restart() {
    stop
    start
}

logs() {
    docompose logs $@
}

cmd() {
    docompose "$@"
}

query_network() {
    # Mainnet or Testnet network
    NETWORK=$(whiptail --notags --title "Select Network" --menu \
    "Which network do you want to run on?" 12 60 5 \
    "goerli" "GÃ¶rli (nÃ© Prater) Testnet" \
    "mainnet" "Ethereum Mainnet" \
    "gnosis" "Gnosis Chain (nÃ© xDai)" \
    "sepolia" "Sepolia Testnet (permissioned validators)" 3>&1 1>&2 2>&3)

    case "${NETWORK}" in
       "mainnet")
           echo "You chose to run on Ethereum mainnet"
           ;;
       "gnosis")
           echo "You chose to run on Gnosis Chain"
           ;;
       "goerli" | "sepolia" )
           echo "You chose to run on ${NETWORK} testnet"
           ;;
       *)
           echo "You chose Cancel"
           exit 1
           ;;
    esac
}

query_deployment() {
    if [ ${NETWORK} = "gnosis" ]; then
      __deployment=$(whiptail --notags --title "Select deployment type" --menu \
      "What kind of deployment do you want to run?" 11 80 3 \
      "node" "Ethereum node - consensus, execution and validator client" \
      "rpc" "Ethereum RPC node - consensus and execution client" 3>&1 1>&2 2>&3)
    elif uname -a | grep -q aarch64; then
      __deployment=$(whiptail --notags --title "Select deployment type" --menu \
      "What kind of deployment do you want to run?" 11 80 4 \
      "node" "Ethereum node - consensus, execution and validator client" \
      "rocket" "Validator client only - integrate with RocketPool" \
      "rpc" "Ethereum RPC node - consensus and execution client" 3>&1 1>&2 2>&3)
    else
      __deployment=$(whiptail --notags --title "Select deployment type" --menu \
      "What kind of deployment do you want to run?" 12 80 5 \
      "node" "Ethereum node - consensus, execution and validator client" \
      "rocket" "Validator client only - integrate with RocketPool" \
      "blox" "Blox SSV node - consensus, execution and ssv-node" \
      "rpc" "Ethereum RPC node - consensus and execution client" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your deployment choice is:" "${__deployment}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_validator_client() {
    if [ ${NETWORK} = "gnosis" ]; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
      "Which validator client do you want to run?" 9 65 2 \
      "lighthouse-vc-only.yml" "Lighthouse validator client" \
      "teku-vc-only.yml" "Teku validator client" 3>&1 1>&2 2>&3)
    elif [ "${__deployment}" = "rocket" ]; then
        if uname -a | grep -q aarch64; then
          CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
          "Which validator client do you want to run?" 9 65 2 \
          "lighthouse-vc-only.yml" "Lighthouse validator client" \
          "teku-vc-only.yml" "Teku validator client" 3>&1 1>&2 2>&3)
        else
          CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
          "Which validator client do you want to run?" 9 65 2 \
          "teku-vc-only.yml" "Teku validator client" \
          "lighthouse-vc-only.yml" "Lighthouse validator client" 3>&1 1>&2 2>&3)
        fi
    elif uname -a | grep -q aarch64; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
      "Which validator client do you want to run?" 9 65 2 \
      "lighthouse-vc-only.yml" "Lighthouse validator client" \
      "teku-vc-only.yml" "Teku validator client" 3>&1 1>&2 2>&3)
    else
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
      "Which validator client do you want to run?" 11 65 4 \
      "teku-vc-only.yml" "Teku validator client" \
      "lighthouse-vc-only.yml" "Lighthouse validator client" \
      "lodestar-vc-only.yml" "Lodestar validator client" \
      "prysm-vc-only.yml" "Prysm validator client" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your validator client file is:" "${CONSENSUS_CLIENT}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_consensus_client() {
    if [ ${NETWORK} = "gnosis" ]; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 10 65 3 \
      "lighthouse-base.yml" "Lighthouse (Rust) - consensus and validator client" \
      "teku-base.yml" "Teku (Java) - consensus and validator client" \
      "lodestar-base.yml" "Lodestar (Javascript) - consensus and validator client" 3>&1 1>&2 2>&3)
    elif uname -a | grep -q aarch64; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 10 65 3 \
      "nimbus-base.yml" "Nimbus (Nim) - consensus and validator client" \
      "lodestar-base.yml" "Lodestar (Javascript) - consensus and validator client" \
      "lighthouse-base.yml" "Lighthouse (Rust) - consensus and validator client" \
      "teku-base.yml" "Teku (Java) - consensus and validator client" 3>&1 1>&2 2>&3)
    else
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 12 65 5 \
      "teku-base.yml" "Teku (Java) - consensus and validator client" \
      "lighthouse-base.yml" "Lighthouse (Rust) - consensus and validator client" \
      "nimbus-base.yml" "Nimbus (Nim) - consensus and validator client" \
      "lodestar-base.yml" "Lodestar (Javascript) - consensus and validator client" \
      "prysm-base.yml" "Prysm (Go) - consensus and validator client" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your consensus client file is:" "${CONSENSUS_CLIENT}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_consensus_only_client() {
    if [ ${NETWORK} = "gnosis" ]; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 10 65 3 \
      "lighthouse-cl-only.yml" "Lighthouse (Rust) - consensus client" \
      "teku-cl-only.yml" "Teku (Java) - consensus client" 3>&1 1>&2 2>&3)
    elif uname -a | grep -q aarch64; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 10 65 3 \
      "nimbus-cl-only.yml" "Nimbus (Nim) - consensus client" \
      "lodestar-cl-only.yml" "Lodestar (Javascript) - consensus client" \
      "lighthouse-cl-only.yml" "Lighthouse (Rust) - consensus client" \
      "teku-cl-only.yml" "Teku (Java) - consensus client" 3>&1 1>&2 2>&3)
    else
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 12 65 5 \
      "teku-cl-only.yml" "Teku (Java) - consensus client" \
      "lighthouse-cl-only.yml" "Lighthouse (Rust) - consensus client" \
      "nimbus-cl-only.yml" "Nimbus (Nim) - consensus client" \
      "lodestar-cl-only.yml" "Lodestar (Javascript) - consensus client" \
      "prysm-cl-only.yml" "Prysm (Go) - consensus client" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your consensus client file is:" "${CONSENSUS_CLIENT}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_custom_execution_client() {
        EL_CUSTOM_NODE=$(whiptail --title "Configure custom execution client" --inputbox "What is the URL for your custom execution client? (right-click to paste)" 10 60 3>&1 1>&2 2>&3)

        exitstatus=$?
        if [ $exitstatus -eq 0 ]; then
            echo "Your custom execution client is:" $EL_CUSTOM_NODE
        else
            echo "You chose Cancel."
            exit 1
        fi

        while true; do
            JWT_SECRET=$(whiptail --title "Configure JWT secret" --inputbox "What is the JWT secret shared with the execution client? (right-click to paste)" 10 60 3>&1 1>&2 2>&3)

            exitstatus=$?
            if [ $exitstatus -eq 0 ]; then
                if [[ ${#JWT_SECRET} -eq 64 ]]; then
                  echo "JWT Secret set. Please make sure it matches on CL and EL."
                  break
                else
                  whiptail --msgbox "The JWT secret needs to be exactly 32 bytes, 64 hex characters long. You can try again or Cancel on the next screen." 10 75
                fi
            else
                echo "You chose Cancel."
                exit 1
            fi
        done
}

query_execution_client() {
    if [ ${NETWORK} = "gnosis" ]; then
      EXECUTION_CLIENT=$(whiptail --notags --title "Select execution client" --menu \
      "Which execution client do you want to run?" 9 60 2 \
      "nethermind.yml" "Nethermind (.NET)" 3>&1 1>&2 2>&3)
    elif uname -a | grep -q aarch64; then
      EXECUTION_CLIENT=$(whiptail --notags --title "Select execution client" --menu \
      "Which execution client do you want to run?" 9 60 3 \
      "besu.yml" "Besu (Java)" \
      "nethermind.yml" "Nethermind (.NET)" \
      "geth.yml" "Geth (Go)" 3>&1 1>&2 2>&3)
    else
      EXECUTION_CLIENT=$(whiptail --notags --title "Select execution client" --menu \
      "Which execution client do you want to run?" 12 60 5 \
      "besu.yml" "Besu (Java)" \
      "nethermind.yml" "Nethermind (.NET)" \
      "geth.yml" "Geth (Go)" \
      "erigon.yml" "Erigon - alpha (Go)" \
      "NONE" "Custom - Distributed" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -ne 0 ]; then
        echo "You chose Cancel."
        exit 1
    fi

    if [ "${EXECUTION_CLIENT}" == "NONE" ]; then
        unset EXECUTION_CLIENT
        query_custom_execution_client
        EL_NODE="${EL_CUSTOM_NODE}"
    else
        echo "Your execution client file is:" "${EXECUTION_CLIENT}"
	if [[ "${CONSENSUS_CLIENT}" =~ "nimbus-" ]]; then
            EL_NODE="ws://execution:8551"
	else
            EL_NODE="http://execution:8551"
	fi
	if [ "${EXECUTION_CLIENT}" = "erigon.yml" ]; then
	    echo "Please remember to set your EL_WS_PORT to match EL_RPC_PORT for Erigon"
	fi
    fi
}

query_grafana() {
    if (whiptail --title "Select Option" --yesno "Do you want to use Grafana dashboards?" 10 60) then
        GRAFANA_CLIENT="grafana.yml:grafana-shared.yml"
    else
        unset GRAFANA_CLIENT
    fi
}

query_remote_beacon() {
    if [ "${__deployment}" = "rocket" ]; then
        REMOTE_BEACON=$(whiptail --title "Configure remote consensus client" --inputbox "What is the URL for your remote consensus client? (right-click to paste)" 10 60 "http://eth2:5052" 3>&1 1>&2 2>&3)
    else
        REMOTE_BEACON=$(whiptail --title "Configure remote consensus client" --inputbox "What is the URL for your remote consensus client? (right-click to paste)" 10 60 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your remote consensus client is:" "${REMOTE_BEACON}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_checkpoint_beacon() {
    case "${NETWORK}" in
        "sepolia")
            RAPID_SYNC_URL="https://sepolia.beaconstate.info"
            ;;
        "goerli")
            RAPID_SYNC_URL="https://goerli.beaconstate.info"
            ;;
        "mainnet")
            RAPID_SYNC_URL="https://beaconstate.info"
            ;;
        *)
            RAPID_SYNC_URL=""
            ;;
    esac

    RAPID_SYNC_URL=$(whiptail --title "Configure checkpoint consensus client" --inputbox "What is the URL for your checkpoint consensus client? (right-click to paste)" 10 60 ${RAPID_SYNC_URL} 3>&1 1>&2 2>&3)

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your checkpoint consensus client is:" "${RAPID_SYNC_URL}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_graffiti() {
    GRAFFITI=$(whiptail --title "Configure Graffiti" --inputbox "What Graffiti do you want to send with your blocks? (up to 32 characters)" 10 37 "ðŸ¼eth-dockerðŸ¼" 3>&1 1>&2 2>&3)

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "your Graffiti is:" "${GRAFFITI}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_rapid_sync() {
    RAPID_SYNC_URL=""
    if (whiptail --title "Select Option" --yesno "Do you want to use CL rapid sync with remote checkpoint?" 10 60) then
        query_checkpoint_beacon
    fi
}

query_coinbase() {
    while true; do
        FEE_RECIPIENT=$(whiptail --title "Configure Rewards Address" --inputbox "What is the address you want transaction rewards to be sent to by default? (right-click to paste, CANNOT be an ENS)" 10 60 3>&1 1>&2 2>&3)

        exitstatus=$?
        if [ $exitstatus -eq 0 ]; then
            if [[ ${FEE_RECIPIENT} == 0x* && ${#FEE_RECIPIENT} -eq 42 ]]; then
              echo "Your rewards address is:" ${FEE_RECIPIENT}
              break
            else
              whiptail --msgbox "${FEE_RECIPIENT} is not a valid ETH address. You can try again or Cancel on the next screen.\n\nThe client will not start successfully until a valid ETH rewards address has been set." 16 75
            fi
        else
            echo "You chose Cancel."
            if [ $__during_update -eq 1 ]; then
                echo
                echo "Please make requested changes manually or run \"./ethd update\" again"
                echo "before running \"./ethd up\"."
                echo
                echo "Without a FEE_RECIPIENT set in \".env\", containers will not"
                echo "start successfully. Already running containers will keep running with the"
                echo "old configuration until you are ready to restart them."
            fi
            echo
            # If this is called by an older version of ethd, envmigrate
            # is in its own bash instance: Need to kill the ethd parent
            if ps $PPID | grep -q "ethd"; then
                kill $PPID
            fi
            exit 1
        fi
    done
}

query_override() {
    if ! (whiptail --title "Select Option" --yesno --defaultno "Do you want to set an Override TTD?" 10 60) then
        OVERRIDE_TTD=""
        return
    fi

    case "${NETWORK}" in
        "sepolia")
            OVERRIDE_TTD=17000000000000000
            ;;
        "goerli")
            OVERRIDE_TTD=10790000
            ;;
        "mainnet")
            OVERRIDE_TTD=58750000000000000000000
            ;;
        *)
            OVERRIDE_TTD=100000000000000000000000
            ;;
    esac

    OVERRIDE_TTD=$(whiptail --title "Configure Override TTD" --inputbox "What is the override TTD for the ${NETWORK} network? Set as EMPTY to use the client default (right-click to paste)" 10 60 ${OVERRIDE_TTD} 3>&1 1>&2 2>&3)

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your override TTD for ${NETWORK} is:" $OVERRIDE_TTD
    else
        echo "You chose Cancel."
        exit 0
    fi
}

query_mev() {
    if (whiptail --title "Select Option" --yesno "Do you want to use MEV Boost?" 10 60) then
        MEV_BOOST="true"
        case "${NETWORK}" in
            "sepolia")
                MEV_RELAYS=https://0x845bd072b7cd566f02faeb0a4033ce9399e42839ced64e8b2adcfc859ed1e8e1a5a293336a49feac6d9a5edb779be53a@builder-relay-sepolia.flashbots.net
                ;;
            "goerli")
                MEV_RELAYS=https://0xafa4c6985aa049fb79dd37010438cfebeb0f2bd42b115b89dd678dab0670c1de38da0c4e9138c9290a398ecd9a0b3110@builder-relay-goerli.flashbots.net,https://0x821f2a65afb70e7f2e820a925a9b4c80a159620582c1766b1b09729fec178b11ea22abb3a51f07b288be815a1a2ff516@bloxroute.max-profit.builder.goerli.blxrbdn.com,https://0x8f7b17a74569b7a57e9bdafd2e159380759f5dc3ccbd4bf600414147e8c4e1dc6ebada83c0139ac15850eb6c975e82d0@builder-relay-goerli.blocknative.com,https://0xaa1488eae4b06a1fff840a2b6db167afc520758dc2c8af0dfb57037954df3431b747e2f900fe8805f05d635e9a29717b@relay-goerli.edennetwork.io
                ;;
            "mainnet")
                MEV_RELAYS=https://0xac6e77dfe25ecd6110b8e780608cce0dab71fdd5ebea22a16c0205200f2f8e2e3ad3b71d3499c54ad14d6c21b41a37ae@boost-relay.flashbots.net,https://0x8b5d2e73e2a3a55c6c87b8b6eb92e0149a125c852751db1422fa951e42a09b82c142c3ea98d0d9930b056a3bc9896b8f@bloxroute.max-profit.blxrbdn.com,https://0x9000009807ed12c1f08bf4e81c6da3ba8e3fc3d953898ce0102433094e5f22f21102ec057841fcb81978ed1ea0fa8246@builder-relay-mainnet.blocknative.com,https://0xb3ee7afcf27f1f1259ac1787876318c6584ee353097a50ed84f51a1f21a323b3736f271a895c7ce918c038e4265918be@relay.edennetwork.io,https://0xa1559ace749633b997cb3fdacffb890aeebdb0f5a3b6aaa7eeeaf1a38af0a8fe88b9e4b1f61f236d2e64d95733327a62@relay.ultrasound.money
                ;;
            *)
                MEV_RELAYS=""
                ;;
        esac
        MEV_RELAYS=$(whiptail --title "Configure MEV relays" --inputbox "What MEV relay(s) do you want to use? (right-click to paste)" 10 60 ${MEV_RELAYS} 3>&1 1>&2 2>&3)

        exitstatus=$?
        if [ $exitstatus -eq 0 ]; then
            echo "Your MEV relay(s): " ${MEV_RELAYS}
        else
            echo "You chose Cancel."
            exit 0
        fi
    else
        MEV_BOOST="false"
        MEV_RELAYS=""
    fi
}

set_value_in_env() {
    # Assumes that "var" has been set to the name of the variable to be changed
    if [ "${!var+x}" ]; then
        if ! grep -qF "${var}" "${ENV_FILE}" 2>/dev/null ; then
            echo "${var}=${!var}" >> "${ENV_FILE}"
        else
            sed -i'.original' -e "s~^\(${var}\s*=\s*\).*$~\1${!var}~" "${ENV_FILE}"
        fi
    fi
}

config () {
    check_for_snap
    if [[ "$__distro" = "ubuntu" ]]; then
      __major_version=$(lsb_release -r | cut -d: -f2 | sed s/'^\t'// | cut -d. -f1)
      if [ ${__major_version} -lt 20 ]; then
         echo
         echo "Ubuntu ${__major_version} is older than the recommended versions 22.04 or 20.04"
         echo
      fi
    fi
    # Create ENV file if needed
    if ! [[ -f "${ENV_FILE}" ]]; then
        ENV_TEMPLATE="default.env"

        echo "Your configuration file template is:" "${ENV_TEMPLATE}"

        if [ "${EUID}" -eq 0 ]; then
          sudo -u "${OWNER}" cp "${ENV_TEMPLATE}" "${ENV_FILE}"
        else
          cp "${ENV_TEMPLATE}" "${ENV_FILE}"
        fi
    fi

    query_network
    query_deployment
    case "${__deployment}" in
      "node")
        query_consensus_client
        ;;
      "validator" | "rocket")
        query_validator_client
        ;;
      "blox" | "rpc")
        query_consensus_only_client
        ;;
      *)
        echo "Unknown deployment ${__deployment}, this is a bug."
        exit 1
        ;;
    esac

    MEV_BOOST=false
    if [[ ! "${CONSENSUS_CLIENT}" =~ "-vc-only.yml" ]]; then
        CL_NODE="http://consensus:5052"

        query_execution_client
        query_rapid_sync
        query_mev
        query_grafana
	query_coinbase
	query_override
        if [ ${__deployment} = "node" ]; then
          query_graffiti
        fi
    else
        unset EXECUTION_CLIENT
        unset GRAFANA_CLIENT

        query_remote_beacon
        CL_NODE="${REMOTE_BEACON}"
        query_coinbase
        query_graffiti
    fi

    COMPOSE_FILE="${CONSENSUS_CLIENT}"
    if [ "${EXECUTION_CLIENT+x}" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:${EXECUTION_CLIENT}"
    fi
    if [ "${__deployment}" = "blox" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:blox-ssv2.yml"
    fi
    if [ "${GRAFANA_CLIENT+x}" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:${GRAFANA_CLIENT}"
    fi
    if [ "${MEV_BOOST}" = "true" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:mev-boost.yml"
    fi
    if [ "${NETWORK}" = "goerli" -o "${NETWORK}" = "sepolia" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:deposit-cli.yml"
    fi
    if [ "${__deployment}" = "rocket" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:ext-network.yml"
        sed -i'.original' -e "s~name: traefik_default~name: rocketpool_net~" ext-network.yml
    fi

    echo "Your COMPOSE_FILE is:" "${COMPOSE_FILE}"

    var=FEE_RECIPIENT
    set_value_in_env
    var=GRAFFITI
    set_value_in_env
    var=CL_NODE
    set_value_in_env
    var=RAPID_SYNC_URL
    set_value_in_env
    var=COMPOSE_FILE
    set_value_in_env
    var=EL_NODE
    set_value_in_env
    var=NETWORK
    set_value_in_env
    var=OVERRIDE_TTD
    set_value_in_env
    var=MEV_BOOST
    set_value_in_env
    var=MEV_RELAYS
    set_value_in_env

    docompose build --pull
    docompose --profile tools build --pull
    exec 3>&1
    exec 4>&2
    exec 1> /dev/null
    exec 2> /dev/null
    docompose pull || true
    exec 1>&3
    exec 2>&4
}

printhelp() {
    me=$(basename "${BASH_SOURCE}")
    echo "usage: ${me} [help|-h|--help] <subcommand>"
    echo ""
    echo "optional arguments:"
    echo "  help | -h | --help"
    echo "    print this message and exit"
    echo ""
    echo "subcommands:"
    echo "  install"
    echo "     attempts to install docker and docker-compose for you"
    echo "  config"
    echo "     configures eth-docker with your choice of Ethereum clients"
    echo "  keyimport [--non-interactive | --path ]"
    echo "     import validator keys from .eth/validator_keys"
    echo "     --path specifies an alternate import path"
    echo "     --non-interactive is for use from another script,"
    echo "       in which case KEYSTORE_PASSWORD must be set to the password"
    echo "       shared by all keystore-m json files, and in the case of Prysm,"
    echo "       WALLET_PASSWORD must be set to the password for Prysm's wallet"
    echo "  keys ACTION"
    echo "     list, delete, import keys; their fee recipients; and gas fees"
    echo "     Run without ACTION to get help text"
    echo "  update [--keep-targets] "
    echo "     updates all client versions and eth-docker itself"
    echo "     --keep-targets will keep your custom build targets in .env"
    echo "  start"
    echo "     starts the Ethereum node software"
    echo "  stop"
    echo "     stops the Ethereum node software"
    echo "  restart"
    echo "     restarts the Ethereum node software, a combination of stop and start"
    echo "  logs"
    echo "     shows logs"
    echo "  cmd <command>"
    echo "     executes an arbitrary docker-compose command. Use \"cmd help\" to list them"
    echo "  terminate"
    echo "     stops the Ethereum node software and destroys all data stores"
    echo "  prune-geth"
    echo "     stops the Geth execution client and prunes its DB. This takes about 4-5 hours"
    echo ""
    echo ""
    echo "The logs subcommand can be appended by flags and specify the container(s). example: "
    echo ""
    echo "  $me logs -f --tail 500 execution"
    echo "    shows logs only for execution service"
    echo ""
    echo ""
    echo "Be sure to run the config command as a non-root user, and all other commands"
    echo "either with sudo, or as a user who is part of the \"docker\" group"
    echo ""
}

if [[ "$#" -eq 0 || "$1" == "help" || "$1" == "-h" || "$1" == "--help" ]]; then
    printhelp
    exit 0
fi

cd "$(dirname "$(realpath ${BASH_SOURCE})")"
# Use this to make sure root doesn't end up owning files
if [[ "$OSTYPE" == "darwin"* ]]; then
    OWNER=$(stat -f '$Su' .)
else
    OWNER=$(stat -c '%U' .)
fi

if [ "${OWNER}" == "root" ]; then
    echo "Please install eth-docker as a non-root user."
    exit 1
fi

ENV_FILE=.env
__during_update=0

command="$1"
shift

determine_distro
determine_sudo
handle_root
determine_docker
determine_compose

if [ $command = "install" ]; then
    $command "$@"
    exit "$?"
fi

if ! type -P whiptail >/dev/null 2>&1; then
    echo "Please install the package whiptail or newt before running this script"
    exit 1
fi

if ! dodocker images >/dev/null 2>&1; then
    echo "Please ensure you can call $__docker_exe before running this script."
    exit 1
fi

if ! docompose --help >/dev/null 2>&1; then
    echo "Please ensure you can call $__compose_exe before running this script"
    exit 1
fi

$command "$@"
