#!/usr/bin/env bash
#set -euo pipefail
set -uo pipefail

__docker_exe="docker"
__compose_exe="docker compose"
__compose_upgraded=0

dodocker() {
    $__docker_exe "$@"
}

docompose() {
    $__compose_exe "$@"
}

determine_distro() {
    # Determine OS platform
    __uname=$(uname | tr "[:upper:]" "[:lower:]")
    # If Linux, try to determine specific distribution
    if [ "$__uname" == "linux" ]; then
        # If available, use LSB to identify distribution
        if [ -n "$(command -v lsb_release 2>/dev/null)" ]; then
            __distro=$(lsb_release -i | cut -d: -f2 | sed s/'^\t'//)
        # Otherwise, use release info file
        else
            #__distro=$(ls -d /etc/[A-Za-z]*[_-][rv]e[lr]* | grep -v "lsb" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1)
            __distro=$(find /etc -maxdepth 1 -type f -name '[A-Za-z]*[_-][rv]e[lr]*' | grep -v "lsb" | cut -d'/' -f3 | cut -d'-' -f1 | cut -d'_' -f1)
        fi
    else
        __distro=""
    fi
    # For everything else (or if above failed), just use generic identifier
    [ "$__distro" == "" ] && __distro=$__uname
    unset __uname
    __distro=$(echo "$__distro" | tr "[:upper:]" "[:lower:]")
}

determine_sudo() {
    systemctl status docker >/dev/null
    result=$?
    if [ ! "${result}" -eq 0 ]; then
        echo "The docker daemon is not running. Please check docker installation."
        echo "\"sudo systemctl status docker\" and \"sudo journalctl -fu docker\" will be helpful."
        echo "Aborting."
        exit 1
    fi

    __maybe_sudo=""
    if ! docker images >/dev/null 2>&1; then
        echo "Will use sudo to access docker"
        __maybe_sudo="sudo"
    fi
}

determine_docker() {
    if [ -n "$__maybe_sudo" ]; then
        __docker_exe="sudo $__docker_exe"
    fi
}

determine_compose() {
# Check for Compose V2 (docker compose) vs Compose V1 (docker-compose)
  if docker compose version >/dev/null 2>&1; then
    __compose_exe="docker compose"
    __old_compose=0
  else
    __compose_exe="docker-compose"
    __old_compose=1
    __compose_version=$($__maybe_sudo docker-compose --version | sed -n -E -e "s/.*version [v]?([0-9.-]*).*/\1/ip")
    if [ -n "${ETHDSECUNDO-}" ]  || [ ! "${command}" = "update" ]; then # Don't run this twice
      echo
      echo "You are using docker-compose ${__compose_version}, which is unsupported by Docker, Inc. from July 2023 on"
      echo "eth-docker will stop supporting it with Dencun, sometime fall 2023."
      echo ""
      echo "It is recommended that you replace compose V1 with compose V2."
      while true; do
        read -rp "Do you want to update compose to V2? (yes/no) " yn
        case $yn in
          [Nn]* ) echo "Please be sure to update docker-compose yourself!"; break;;
           * ) upgrade_compose; break;;
        esac
      done
    fi
  fi

  if [ -n "$__maybe_sudo" ]; then
    __compose_exe="sudo $__compose_exe"
  fi
}

upgrade_compose() {
  if ! type -P docker-compose >/dev/null 2>&1; then
    echo "Compose has already been updated to V2"
    return
  fi
  echo "Updating compose to V2"
  if [[ "$__distro" = "ubuntu" ]]; then
    ${__auto_sudo} apt-get update && ${__auto_sudo} apt-get install -y ca-certificates curl gnupg lsb-release
    __major_version=$(lsb_release -r | cut -d: -f2 | sed s/'^\t'// | cut -d. -f1)
    if [ "${__major_version}" -lt 20 ]; then
      echo "This script cannot update compose on Ubuntu ${__major_version}. Consider upgrading to 22.04 or 20.04"
      exit 0
    fi
    ${__auto_sudo} apt-get remove -y docker-compose
    echo "Removed docker-compose"
    ${__auto_sudo} mkdir -p /etc/apt/keyrings
    ${__auto_sudo} curl -fsSL https://download.docker.com/linux/ubuntu/gpg | ${__auto_sudo} gpg --dearmor --yes -o /etc/apt/keyrings/docker.gpg
    ${__auto_sudo} echo \
        "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
        $(lsb_release -cs) stable" | ${__auto_sudo} tee /etc/apt/sources.list.d/docker.list > /dev/null
    ${__auto_sudo} apt-get update
    ${__auto_sudo} apt-get install -y docker-compose-plugin
    echo "Installed docker-compose-plugin"
    __old_compose=0
    __compose_exe="docker compose"
    __compose_upgraded=1
  elif [[ "$__distro" =~ "debian" ]]; then
    ${__auto_sudo} apt-get update && ${__auto_sudo} apt-get -y install ca-certificates curl gnupg lsb-release
    __major_version=$(lsb_release -r | cut -f2)
    if [ "${__major_version}" -lt 10 ]; then
        echo "This script cannot update compose on Debian ${__major_version}. Consider upgrading to 11 or 12."
        exit 0
    fi
    ${__auto_sudo} apt-get remove -y docker-compose
    echo "Removed docker-compose"
    ${__auto_sudo} mkdir -p /etc/apt/keyrings
    ${__auto_sudo} curl -fsSL https://download.docker.com/linux/debian/gpg | ${__auto_sudo} gpg --dearmor --yes -o /etc/apt/keyrings/docker.gpg
    ${__auto_sudo} echo \
        "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
        $(lsb_release -cs) stable" | ${__auto_sudo} tee /etc/apt/sources.list.d/docker.list > /dev/null
    ${__auto_sudo} apt-get update
    ${__auto_sudo} apt-get install -y docker-compose-plugin
    echo "Installed docker-compose-plugin"
    __old_compose=0
    __compose_exe="docker compose"
    __compose_upgraded=1
  else
    echo "This script does not know how to update compose on $__distro"
  fi
}

prep_prometheus() {
# Create custom-prom.yml if it doesn't exist
    if [ ! -f "./prometheus/custom-prom.yml" ]; then
        ${__as_owner} touch "./prometheus/custom-prom.yml"
    fi
}

handle_root() {
    if [ "${EUID}" -eq 0 ]; then
        __as_owner="sudo -u ${OWNER}"
        __auto_sudo=""
    else
        __as_owner=""
        __auto_sudo="sudo"
    fi
}

check_for_snap() {
    if [[ "$__distro" = "ubuntu" && -n "$(command -v snap)" ]] && snap list 2>/dev/null | grep -qw 'docker'; then
        echo
        echo "WARNING! Snap docker package detected. This WILL result in issues."
        echo "Removing the package will delete volumes and require a resync,"
        echo "as well as re-import of all validator keys."
        echo
        echo "Doing so is still highly recommended however."
        echo
        echo "The exact steps depend a little on whether there already is"
        echo "an apt version of docker installed as well, but in a nutshell"
        echo '"./ethd stop" followed by "sudo snap remove --purge docker"'
        echo "and then a reboot, and as needed install docker.io or docker-ce with apt,"
        echo "re-import keys and restart eth-docker."
        echo
        echo "Do join us on EthStaker Discord to work through this issue."
        echo
        echo "Aborting, this is not safe"
        exit 1
    fi
}

install() {
    check_for_snap
    set -e
    read -rp "This will attempt to install docker and make your user part of the docker group. Do you wish to continue? (no/yes) " yn
    case $yn in
        [Yy]* ) ;;
        * ) echo "Aborting, no changes made"; exit 0;;
    esac
    if [[ "$__distro" = "ubuntu" ]]; then
        __major_version=$(lsb_release -r | cut -d: -f2 | sed s/'^\t'// | cut -d. -f1)
        if [ "${__major_version}" -lt 20 ]; then
            echo "This script cannot install docker on Ubuntu ${__major_version}. Consider upgrading to 22.04 or 20.04"
            exit 0
        fi
        if [ -z "$(command -v docker)" ]; then
            ${__auto_sudo} apt-get update && ${__auto_sudo} apt-get install -y ca-certificates curl gnupg lsb-release whiptail bc chrony
            ${__auto_sudo} mkdir -p /etc/apt/keyrings
            ${__auto_sudo} curl -fsSL https://download.docker.com/linux/ubuntu/gpg | ${__auto_sudo} gpg --dearmor --yes -o /etc/apt/keyrings/docker.gpg
            ${__auto_sudo} echo \
                "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
                $(lsb_release -cs) stable" | ${__auto_sudo} tee /etc/apt/sources.list.d/docker.list > /dev/null
            ${__auto_sudo} apt-get update
            ${__auto_sudo} apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            echo "Installed docker-ce and docker-compose-plugin"
        else
            echo "Docker is already installed"
        fi
        __groups=$(${__as_owner} groups)
        if [[ ! "$__groups" =~ "docker" ]]; then
            echo "Making your user part of the docker group"
            ${__auto_sudo} usermod -aG docker "${OWNER}"
            echo "Please run newgrp docker or log out and back in"
        else
            echo "Your user is already part of the docker group"
        fi
    elif [[ "$__distro" =~ "debian" ]]; then
        if [ -z "$(command -v docker)" ]; then
            ${__auto_sudo} apt-get update
            ${__auto_sudo} apt-get -y install ca-certificates curl gnupg lsb-release whiptail bc chrony
            __major_version=$(lsb_release -r | cut -f2)
            if [ "${__major_version}" -lt 10 ]; then
                echo "This script cannot install docker on Debian ${__major_version}. Consider upgrading to 11 or 12."
                exit 0
            fi
            ${__auto_sudo} mkdir -p /etc/apt/keyrings
            ${__auto_sudo} curl -fsSL https://download.docker.com/linux/debian/gpg | ${__auto_sudo} gpg --dearmor --yes -o /etc/apt/keyrings/docker.gpg
            ${__auto_sudo} echo \
                "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \
                $(lsb_release -cs) stable" | ${__auto_sudo} tee /etc/apt/sources.list.d/docker.list > /dev/null
            ${__auto_sudo} apt-get update
            ${__auto_sudo} apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
            echo "Installed docker-ce and docker-compose-plugin"
        else
            echo "Docker is already installed"
        fi
        __groups=$(${__as_owner} groups)
        if [[ ! "$__groups" =~ "docker" ]]; then
            echo "Making your user part of the docker group"
            ${__auto_sudo} usermod -aG docker "${OWNER}"
            echo "Please run newgrp docker or log out and back in"
        else
            echo "Your user is already part of the docker group"
        fi
    else
        echo "This script does not know how to install docker on $__distro"
    fi

    if ! [[ "$__distro" = "ubuntu" ]] || [[ "$__distro" =~ "debian" ]]; then
        exit 0
    fi

    # We only get here on Ubuntu or Debian
    __install_base=$(basename "$(dirname "$(realpath "${BASH_SOURCE[0]}")")")
    if [ "${__install_base}" = "eth-docker" ]; then
        read -rp "Do you want to be able to call 'ethd' from anywhere? (yes/no) " yn
        case $yn in
            [Nn]* ) exit 0;;
            * ) ;;
        esac
        if grep -q "alias ethd" ~/.profile; then
            sed -i'.original' -e "/alias ethd/d" ~/.profile
        fi
        echo "alias ethd=$(realpath "${BASH_SOURCE[0]}")" >>~/.profile
        if grep -q "cat.*\.motd" ~/.profile; then
            sed -i'.original' -e "/cat.*\.motd/d" ~/.profile
        fi
        echo "cat $(dirname "$(realpath "${BASH_SOURCE[0]}")")/.motd" >>~/.profile
        echo "Go ahead and 'source ~/.profile' or log out and back in."
        echo "After that, you can use the command 'ethd'."
    fi
    set +e
    return 0
}

# Warn user if space is low, so they can prune
check_disk_space() {
    __docker_dir=$(dodocker system info --format '{{.DockerRootDir}}')
    __free_space=$(df -P "${__docker_dir}" | awk '/[0-9]%/{print $(NF-2)}')

    re='^[0-9]+$'
    if ! [[ "${__free_space}" =~ $re ]] ; then
        echo "Unable to determine free disk space. This is likely a bug."
        echo "df reports $(df -P "${__docker_dir}") and __free_space is ${__free_space}"
        return
    fi

    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    var="AUTOPRUNE_NM"
    auto_prune=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)

# Literal match intended
# shellcheck disable=SC2076
    if [[ "${value}" =~ "nethermind.yml" ]] && [[ "${__free_space}" -lt 314572800 ]]; then
        echo ""
        echo "You are running Nethermind and have less than 300 GiB of free disk space."
        if [ "${auto_prune}" = true ]; then
          echo "It should currently be auto-pruning, check logs with \"./ethd logs -f --tail 500 execution | grep Full\". Free space:"
        else
          echo "If the below reads above 250 GiB free, prune it with \"./ethd prune-nethermind\""
        fi
        echo ""
        df -h "${__docker_dir}"
        echo ""
    elif [[ "${value}" =~ "geth.yml" ]] && [[ "${__free_space}" -lt 104857600 ]]; then
        echo ""
        echo "You are running Geth and have less than 100 GiB of free disk space."
        echo "If Avail reads 40 GiB or more, prune with ./ethd prune-geth:"
        echo ""
        df -h "${__docker_dir}"
        echo ""
        echo "If it's less than 40 GiB, you may need to resync Geth from scratch."
        echo ""
    elif [[ "${__free_space}" -lt 52428800 ]]; then
        echo ""
        echo "You have less than 50 GiB of free disk space:"
        echo ""
        df -h "${__docker_dir}"
        echo ""
        echo "Pruning does not appear an option for your client mix."
        echo "For Besu, Erigon or Reth, consider a resync."
        echo "If total space is less than 1.5 TiB, consider cloning to a larger drive."
        echo ""
    fi
}

source_build() {
# Check whether there's a source-built client and if so, force it with --no-cache
    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)

    case "${value}" in
        *deposit-cli.yml* )
            docompose --profile tools build --pull --no-cache deposit-cli-new
            ;;
    esac
    case "${value}" in
        *mev-boost.yml* )
            var="MEV_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache mev-boost
            fi
            ;;
    esac
    case "${value}" in
        *reth.yml* )
            var="RETH_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache execution
            fi
            ;;
        *geth.yml* )
            var="GETH_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache execution
            fi
            ;;
        *besu.yml* )
            var="BESU_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache execution
            fi
            ;;
        *nethermind.yml* )
            var="NM_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache execution
            fi
            ;;
        *erigon.yml* )
            var="ERIGON_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache execution
            fi
            ;;
        *nimbus-el.yml* )
            var="NIMEL_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache execution
            fi
            ;;
    esac
    case "${value}" in
        *lighthouse.yml* | *lighthouse-cl-only.yml* )
            var="LH_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache consensus
            fi
            ;;
        *teku.yml* | *teku-cl-only.yml* )
            var="TEKU_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache consensus
            fi
            ;;
        *lodestar.yml* | *lodestar-cl-only.yml* )
            var="LS_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache consensus
            fi
            ;;
        *nimbus.yml* | *nimbus-cl-only.yml* )
            var="NIM_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache consensus
            fi
            ;;
        *prysm.yml* | *prysm-cl-only.yml* )
            var="PRYSM_DOCKERFILE"
            build=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
            if [ "${build}" = "Dockerfile.source" ]; then
                docompose build --pull --no-cache consensus
            fi
            ;;
    esac
}

# Arguments are passed, but shellcheck doesn't recognize that
# shellcheck disable=SC2120
update() {
    if [[ $(${__as_owner} git status --porcelain) ]]; then
        __dirty=1
    else
        __dirty=0
    fi

    __free_space=$(df -P "$(pwd)" | awk '/[0-9]%/{print $(NF-2)}')

    re='^[0-9]+$'
    if ! [[ "${__free_space}" =~ $re ]] ; then
        echo "Unable to determine free disk space. This is likely a bug."
        echo "df reports $(df -P "$(pwd)") and __free_space is ${__free_space}"
    elif [ "$(df -P "$(pwd)" | awk '/[0-9]%/{print $(NF-2)}')" -lt 1024 ]; then
        echo "You have less than 1 MiB of space left on $(pwd)."
        echo "Aborting, as an update is not safe."
        exit 1
    fi

    __docker_dir=$(dodocker system info --format '{{.DockerRootDir}}')
    __free_space=$(df -P "${__docker_dir}" | awk '/[0-9]%/{print $(NF-2)}')

    re='^[0-9]+$'
    if ! [[ "${__free_space}" =~ $re ]] ; then
        echo "Unable to determine free disk space. This is likely a bug."
        echo "df reports $(df -P "${__docker_dir}") and __free_space is ${__free_space}"
    elif [ "${__free_space}" -lt 1048576 ]; then
        echo "You have less than 1 GiB of space left on ${__docker_dir}."
        echo "Aborting, as an update is not safe."
        exit 1
    fi

    if [ -z "${ETHDSECUNDO-}" ]; then
        if ${__as_owner} git branch | grep -q master; then
            ${__as_owner} git branch -m master main
            ${__as_owner} git fetch origin
            ${__as_owner} git branch -u origin/main main
            ${__as_owner} git remote set-head origin -a
        fi
        # Do not track changes to ext-network.yml
        ${__as_owner} git update-index --assume-unchanged ext-network.yml
        ${__as_owner} git config pull.rebase false
        ${__as_owner} git pull
        export GITEXITCODE=$?
        # BASH_SOURCE so newer code gets to do the update. Use an ENV var
        # to avoid infinite loop
        export ETHDSECUNDO=1
        exec "${BASH_SOURCE[0]}" update "$@"
    fi

    __keeptargets=1
    __targetcli=""
    while :
    do
        if [ -z "${1+x}" ]; then
            break
        fi
        case "$1" in
            --keep-targets)
                if [ -n "${__targetcli}" ]; then
                    echo "Error: --keep-targets and --refresh-targets cannot be used together; use either option once only"
                    exit 1
                fi
                __keeptargets=1
                __targetcli="--keep-targets"
                shift
                ;;
            --refresh-targets)
                if [ -n "${__targetcli}" ]; then
                    echo "Error: --keep-targets and --refresh-targets cannot be used together; use either option once only"
                    exit 1
                fi
                __keeptargets=0
                __targetcli="--refresh-targets"
                shift
                ;;
            *)
                echo "Error: Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

# envmigrate used to be called w/ arguments and checks for that
# shellcheck disable=SC2119
    envmigrate

    if [ "${__switched_branch-}" -eq 1 ]; then
        # This code has changed, run it again on the new branch
        export ETHDSECUNDO=1 #Not strictly necessary but this way we don't rely on what happens earlier
        export ETHDSWITCHED=1
        exec "${BASH_SOURCE[0]}" update $__targetcli
    fi

    dodocker system prune --force
    if [ ${__old_compose} -eq 1 ]; then
      docompose --profile tools pull --ignore-pull-failures || true
    else
      docompose --profile tools pull --ignore-pull-failures --quiet || true
    fi
    source_build
    docompose --profile tools build --pull

    echo
    if ! cmp -s "${ENV_FILE}" "${ENV_FILE}".source; then
        ${__as_owner} cp "${ENV_FILE}".source "${ENV_FILE}".bak
        ${__as_owner} rm "${ENV_FILE}".source
        echo "Your ${ENV_FILE} configuration settings have been migrated to a fresh copy. You can \
find the original contents in ${ENV_FILE}.bak."
        if [ $__keeptargets = "0" ]; then
            echo "NB: If you made changes to the source or binary build targets, these have been \
reset to defaults."
        fi
        echo
        echo "List of changes made to ${ENV_FILE} during migration - current on left, original on right:"
        echo
        diff -y --suppress-common-lines "${ENV_FILE}" "${ENV_FILE}".bak
        if [ "$__pre_merge" -eq 1 ]; then
            echo
            echo "You appear to be coming from a pre-merge setup."
            echo "A copy of your original settings is in .env.premerge"
            echo
            echo "Pay special attention to EL_NODE, as failover is no longer supported."
            echo
            echo "Decide whether to use mev-boost. Please see MEV_BOOST in .env for details."
        fi
    else
        echo "No changes made to ${ENV_FILE} during update"
        ${__as_owner} rm "${ENV_FILE}".source
    fi
    if [ "$__el_infura" -eq 1 ]; then
        echo
        echo "Detected use of an Infura project as an EL or failover EL. This is no longer supported with merge."
        echo "Please adjust your EL_NODE variable manually."
    fi
    if [ "$__el_adjusted" -eq 1 ]; then
        echo
        echo "Your EL_NODE variable has been adjusted to use the new Engine API port"
    elif [ "$__pre_merge" -eq 1 ]; then
        echo
        echo "Your EL_NODE variable has not been adjusted to use the new Engine API port, as you had a non-standard value."
        echo "Please take a look and adjust manually."
    fi
    echo
    if [ -z "${GITEXITCODE+x}" ] || [ "${GITEXITCODE}" -eq 0 ]; then
        echo "An \"./ethd up\" command will start using the new images and configuration."
    else
        echo "WARNING"
        echo
        echo "Updating eth-docker failed during \"git pull\""
        echo
        echo "Please try \"git pull\" manually."
        echo "Do not run \"./ethd up\" until git can update eth-docker."
        echo "The current partial update risks startup failure."
    fi
    if [[ "$__distro" = "ubuntu" ]]; then
      __major_version=$(lsb_release -r | cut -d: -f2 | sed s/'^\t'// | cut -d. -f1)
      if [ "${__major_version}" -lt 20 ]; then
         echo
         echo "Ubuntu ${__major_version} is older than the recommended 22.04 or 20.04 version"
         echo
      fi
    fi

    unset ETHDSECUNDO
    unset GITEXITCODE
    if [[ "${ETHDSWITCHED-}" -eq 1 ]]; then
        unset ETHDSWITCHED
        echo
        echo "You were migrated to the $(${__as_owner} git name-rev --name-only HEAD) branch of eth-docker"
        echo
    fi
    delete_erigon
    # If this is called by an older version of ethd, envmigrate
    # is in its own bash instance: Need to kill the ethd parent
# shellcheck disable=SC2009
    if ps $PPID | grep -q "ethd"; then
        echo
        echo "Updated from an older version of eth-docker. You'll see \"Terminated\","
        echo "which keeps the update from running twice. This is normal and will"
        echo "only happen this once."
        echo
        kill $PPID
    fi
    check_for_snap
    if [ "${__dirty}" -eq 1 ]; then
        echo
        echo "WARNING"
        echo
        echo "You have uncommitted local changes to eth-docker, which may interfere with updates."
        echo "Please undo these changes or \"git commit\" them."
        echo "These are the files with local changes:"
        echo
        ${__as_owner} git status --porcelain
    fi
}

# envmigrate used to be called w/ arguments and checks for that
# shellcheck disable=SC2120
envmigrate() {
    if [ -z "${ETHDSECUNDO-}" ]; then
        # We'd only ever hit this if called from an older version of ethd, so let's
        # get the new version executed.
        export ETHDSECUNDO=1
        # Account for different ways that envmigrate was called in older code and
        # set keep-targets correctly regardless
        if [ -z "${KEEPTARGETS-}" ]; then
            __keep=""
            for var in "$@"; do
                if [ "$var" = "--keep-targets" ]; then
                    __keep="--keep-targets"
                fi
            done
        else
            __keep=""
            if [ "${KEEPTARGETS-}" -eq 1 ]; then
                __keep="--keep-targets"
            fi
        fi
        exec "${BASH_SOURCE[0]}" update ${__keep}
    fi

    if [ ! -f "./${ENV_FILE}" ]; then
        return
    fi

    ALL_VARS=( COMPOSE_FILE FEE_RECIPIENT EL_NODE GRAFFITI DEFAULT_GRAFFITI NETWORK MEV_BOOST MEV_RELAYS MEV_MIN_BID MEV_NODE \
            CL_MAX_PEER_COUNT CL_MIN_PEER_COUNT EL_MAX_PEER_COUNT EL_MIN_PEER_COUNT DOMAIN ACME_EMAIL AUTOPRUNE_NM \
            CF_DNS_API_TOKEN CF_ZONE_API_TOKEN CF_ZONE_ID AWS_PROFILE AWS_HOSTED_ZONE_ID GRAFANA_HOST DISTRIBUTED BESU_HEAP TEKU_HEAP \
            PROM_HOST HOST_IP PRYSM_HOST EE_HOST EL_HOST EL_LB EL_WS_HOST EL_WS_LB CL_HOST CL_LB DDNS_SUBDOMAIN IPV6 \
            DDNS_PROXY RAPID_SYNC_URL CL_NODE BEACON_STATS_API BEACON_STATS_MACHINE EL_P2P_PORT CL_P2P_PORT WEB3SIGNER \
            PRYSM_PORT DOPPELGANGER PRYSM_UDP_PORT GRAFANA_PORT PROMETHEUS_PORT KEY_API_PORT TRAEFIK_WEB_PORT TRAEFIK_WEB_HTTP_PORT \
            CL_REST_PORT EL_RPC_PORT EL_WS_PORT EE_PORT ERIGON_TORRENT_PORT LOG_LEVEL JWT_SECRET EL_EXTRAS CL_EXTRAS \
            VC_EXTRAS ARCHIVE_NODE SSV_P2P_PORT SSV_P2P_PORT_UDP ERIGON_P2P_PORT_2 ERIGON_P2P_PORT_3 )
    TARGET_VARS=( NIM_SRC_BUILD_TARGET NIM_DOCKER_TAG NIM_DOCKER_VC_TAG NIM_DOCKERFILE TEKU_SRC_BUILD_TARGET TEKU_DOCKER_TAG \
                TEKU_DOCKERFILE LH_SRC_BUILD_TARGET LH_DOCKER_TAG LH_DOCKERFILE PRYSM_SRC_BUILD_TARGET \
                PRYSM_DOCKER_TAG PRYSM_DOCKER_VC_TAG PRYSM_DOCKERFILE ERIGON_SRC_BUILD_TARGET ERIGON_DOCKER_TAG \
                ERIGON_DOCKERFILE MEV_DOCKERFILE MEV_DOCKER_TAG NIMEL_SRC_BUILD_TARGET NIMEL_DOCKER_TAG NIMEL_DOCKERFILE \
                LS_SRC_BUILD_TARGET LS_DOCKER_TAG LS_DOCKERFILE GETH_SRC_BUILD_TARGET GETH_DOCKER_TAG \
                GETH_DOCKERFILE NM_SRC_BUILD_TARGET NM_DOCKER_TAG NM_DOCKERFILE BESU_SRC_BUILD_TARGET \
                BESU_DOCKER_TAG BESU_DOCKERFILE SSV2_NODE_TAG DEPCLI_SRC_BUILD_TARGET DEPCLI_DOCKER_TAG W3S_DOCKER_TAG \
                PG_DOCKER_TAG RETH_SRC_BUILD_TARGET RETH_DOCKER_TAG RETH_DOCKERFILE NODE_EXPORTER_IGNORE_MOUNT_REGEX )
    OLD_VARS=( LH_PORT PRYSM_WEB_PORT EC_NODE REWARDS_TO GETH_CACHE CF_API_TOKEN \
            EC_HOST EC_LB EC_WS_HOST EC_WS_LB CC_HOST CC_LB EC_P2P_PORT CC_NODE CC_P2P_PORT EC_RPC_PORT EC_WS_PORT )
    NEW_VARS=( CL_P2P_PORT KEY_API_PORT EL_NODE FEE_RECIPIENT EL_EXTRAS CF_DNS_API_TOKEN \
            EL_HOST EL_LB EL_WS_HOST EL_WS_LB CL_HOST CL_LB EL_P2P_PORT CL_NODE CL_P2P_PORT EL_RPC_PORT EL_WS_PORT )

    if [ "${EUID}" -eq 0 ]; then
      # Previous version of this tool when run as root may have created a root-owned .env.bak
      if [ -f ./"${ENV_FILE}".bak ]; then
          ${__as_owner} rm "${ENV_FILE}".bak
      fi
    fi
    ${__as_owner} cp "${ENV_FILE}" "${ENV_FILE}".source
    ${__as_owner} cp default.env "${ENV_FILE}"
    # Detect pre-merge
    if grep -q "FALLBACK_NODE1" ".env.source"; then
      __pre_merge=1
      ${__as_owner} cp .env.source .env.premerge
    else
      __pre_merge=0
    fi
    # Migrate over user settings
    for var in "${ALL_VARS[@]}"; do
        value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env.source" || true)
        if [ -n "${value}" ] || [ "${var}" = "GRAFFITI" ] || [ "${var}" = "MEV_RELAYS" ]; then
            if [ "${var}" = "COMPOSE_FILE" ]; then
                migrate_compose_file
            fi
            if [[ "${var}" = "NETWORK" && "${value}" =~ "prater" ]]; then
                value="goerli"
            fi
            if [[ "${var}" = "HOST_IP" && "${value: -1}" != ":" ]]; then
                value="${value}:" # ComposeV1 requires this so I can do v6
            fi
            # Handle & in GRAFFITI gracefully
            sed -i'.original' -e "s~^\(${var}\s*=\s*\).*\$~\1${value//&/\\&}~" "${ENV_FILE}"
        fi
    done
    if [ $__keeptargets = "1" ]; then
      # Migrate over build targets
      for var in "${TARGET_VARS[@]}"; do
          value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env.source" || true)
          if [ -n "${value}" ]; then
              sed -i'.original' -e "s~^\(${var}\s*=\s*\).*$~\1${value}~" "${ENV_FILE}"
          fi
      done
    fi
    # Move value from old variable name(s) to new one(s)
    for index in "${!OLD_VARS[@]}"; do
        var=${OLD_VARS[index]}
        value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env.source" || true)
        if [ -n "${value}" ]; then
            sed -i'.original' -e "s~^\(${NEW_VARS[index]}\s*=\s*\).*$~\1${value}~" "${ENV_FILE}"
        fi
    done
    # Check whether we run a CL or VC, if so nag about FEE_RECIPIENT
    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    # It's CL&VC, CL-only, or VC-only
# I do mean to match literally
# shellcheck disable=SC2076
    if [[ "${value}" =~ "prysm.yml" || "${value}" =~ "lighthouse.yml" || "${value}" =~ "teku.yml" || "${value}" =~ "nimbus.yml" || "${value}" =~ "lodestar.yml" || \
        "${value}" =~ "-cl-only.yml" || "${value}" =~ "-vc-only.yml" ]]; then
        # Check for rewards
        var="FEE_RECIPIENT"
        value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
        if [[ -z "${value}" || ${value} != 0x* || ${#value} -ne 42 ]]; then
            whiptail --msgbox "A fee recipient ETH wallet address is required in order to start the client. This is for post-merge priority fees and, optionally, MEV. Please enter a valid ETH address in the next screen. Refer to eth-docker docs (https://eth-docker.net/docs/About/Rewards) for more information.\n\nCAUTION: \"./ethd up\" will fail if no valid address is set" 16 75
            __during_update=1
            query_coinbase
            set_value_in_env
        fi
    fi

    # User signals it's a distributed setup and not to nag
    # Ditto do not nag if we switched branch, as the code that does
    # the check won't be accurate
    var="DISTRIBUTED"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if [[ "${value}" = "true" || "${__switched_branch-}" -eq 1 ]]; then
        ${__as_owner} rm .env.original
        return
    fi
    # Check for CL and EL, nag if we have only one without the other
    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    # Case 1 ... CL, do we have an EL?
# I do mean to match literally
# shellcheck disable=SC2076
    if [[ "${value}" =~ "prysm.yml" || "${value}" =~ "lighthouse.yml" || "${value}" =~ "teku.yml" || "${value}" =~ "nimbus.yml" || "${value}" =~ "lodestar.yml" || "${value}" =~ "-cl-only.yml" ]]; then
        if [[ ! "${value}" =~ "geth.yml" && ! "${value}" =~ "besu.yml" && ! "${value}" =~ "erigon.yml" && ! "${value}" =~ "nethermind.yml"  && ! "${value}" =~ "nimbus-el.yml" && ! "${value}" =~ "reth.yml" ]]; then
            whiptail --msgbox "An Execution Layer client is required alongside your Consensus Layer client since Ethereum Merge.\n\nIf you run a distributed setup, you can shut off this nag screen by setting DISTRIBUTED=true in .env" 16 75
        fi
    # Case 2 ... EL, do we have a CL?
    elif [[ "${value}" =~ "geth.yml" || "${value}" =~ "besu.yml" || "${value}" =~ "erigon.yml" || "${value}" =~ "nethermind.yml" || "${value}" =~ "nimbus-el.yml" || "${value}" =~ "reth.yml" ]]; then
        if [[ ! "${value}" =~ "prysm.yml"  && ! "${value}" =~ "lighthouse.yml"  && ! "${value}" =~ "teku.yml"  && ! "${value}" =~ "nimbus.yml"  && ! "${value}" =~ "lodestar.yml"  && ! "${value}" =~ "-cl-only.yml" ]]; then
            whiptail --msgbox "A Consensus Layer client is required alongside your Execution Layer client since Ethereum Merge.\n\nIf you run a distributed setup, you can shut off this nag screen by setting DISTRIBUTED=true in .env" 16 75
        fi
    fi
    # Adjust EL_NODE as needed
    __el_adjusted=0
    __el_infura=0
    var="EL_NODE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
# I do mean to match literally
# shellcheck disable=SC2076
    if [[ "${value}" =~ "infura.io" ]]; then
       __el_infura=1
    fi
    if [[ "${value}" =~ "http://execution:8545" ]]; then
       EL_NODE="http://execution:8551"
       set_value_in_env
       __el_adjusted=1
    elif [[ "${value}" =~ "ws://execution:8546" || "${value}" =~ "ws://execution:8545" ]]; then
       EL_NODE="ws://execution:8551"
       set_value_in_env
       __el_adjusted=1
    fi
    ${__as_owner} rm .env.original
}

migrate_compose_file() {
# When this gets called $var is COMPOSE_FILE and $value is what is set in .env for it
# Some files have been renamed and others removed altogether
    FROM_YML=( ec-shared.yml ec-traefik.yml cc-shared.yml grafana-insecure.yml prysm-web-insecure.yml lh-base-notz.yml lh-validator-notz.yml lh-slasher.yml teku-base-notz.yml teku-validator-notz.yml lh-consensus.yml lh-validator.yml lodestar-consensus.yml lodestar-validator.yml nimbus-consensus.yml prysm-consensus.yml prysm-consensus-rest.yml prysm-validator.yml teku-consensus.yml teku-validator.yml lh-base.yml lh-vc-only.yml lh-cl-only.yml nm.yml lighthouse-base.yml teku-base.yml nimbus-base.yml prysm-base.yml lodestar-base.yml traefik-cf-v6.yml prysm-web.yml blank-grafana.yml lh-grafana.yml lhcc-grafana.yml nimbus-grafana.yml prysm-grafana.yml teku-grafana.yml geth-grafana.yml erigon-grafana.yml oe.yml teku-stats.yml lh-stats.yml lh-stats-consensus.yml lh-stats-validator.yml traefik-shared.yml lighthouse-slasher.yml prysm-slasher.yml )
    TO_YML=( el-shared.yml el-traefik.yml cl-shared.yml grafana-shared.yml prysm-web-shared.yml lighthouse-base.yml lighthouse-vc-only.yml lighthouse-slasher.yml teku-base.yml teku-vc-only.yml lighthouse-cl-only.yml lighthouse-vc-only.yml lodestar-cl-only.yml lodestar-vc-only.yml nimbus-cl-only.yml prysm-cl-only.yml prysm-cl-only.yml prysm-vc-only.yml teku-cl-only.yml teku-vc-only.yml lighthouse-base.yml lighthouse-vc-only.yml lighthouse-cl-only.yml nethermind.yml lighthouse.yml teku.yml nimbus.yml prysm.yml lodestar.yml traefik-cf.yml "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" "" )

    __old_grafana=0
    __new_grafana=0
    __grafana_regex=".+-grafana\.yml"
    __switched_branch=0
    IFS=":"
    set -o noglob
# Globbing is off
# shellcheck disable=SC2206
    __ymlarray=($value) # split+glob with glob disabled, and split using : as delimiter
    set +o noglob
    # Unset restores default
    unset IFS

    value=""
    for n in "${!__ymlarray[@]}"; do
        __ymlfile="${__ymlarray[n]}"
        if [[ "${__ymlfile}" =~ $__grafana_regex ]]; then
            __old_grafana=1
        fi
        if [ "${__ymlfile}" = "grafana.yml" ]; then
            __new_grafana=1
        fi
        for index in "${!FROM_YML[@]}"; do
            if [ "${FROM_YML[index]}" = "${__ymlfile}" ]; then
                __ymlfile=${TO_YML[index]}
                break
            fi
        done
        if [ -n "${__ymlfile}" ]; then
            if [ -z "${value}" ]; then
                value="${__ymlfile}"
            else
                value="${value}:${__ymlfile}"
            fi
        fi
    done
    if [ "${__new_grafana}" = 0 ] && [ "${__old_grafana}" = 1 ]; then
        value="${value}:grafana.yml"
    fi
}

delete_erigon() {
    # Check for Erigon
    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
# I do mean to match literally
# shellcheck disable=SC2076
    if [[ ! "${value}" =~ "erigon.yml" ]]; then
        return
    fi

    if ! dodocker volume ls -q | grep -q "$(basename "$(realpath .)")[_-]erigon-ec-data"; then
        return
    fi

    echo "Detected Erigon. For merge, it will need to be re-synced from scratch"
    echo
    while true; do
        read -rp "WARNING - About to delete the Erigon database. Do you wish to continue? (Y/n) " yn
        case $yn in
            [Nn]o | [Nn]  ) echo "Aborting, no changes made"; exit 1;;
            * ) break;;
        esac
    done

    echo "Stopping Erigon container"
    dodocker stop "$(dodocker ps -q -f "name=erigon")" && dodocker rm -f "$(dodocker ps -a -q -f "name=erigon")"
    docompose stop execution && docompose rm -f execution
    dodocker volume rm "$(dodocker volume ls -q -f "name=erigon-ec-data")"
    echo ""
    echo "Erigon stopped and database deleted."
    echo ""
}

resync-execution() {
    # Check for EL client
    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)

    case "${value}" in
        *erigon.yml* ) __el_volume='erigon-el-data'; __el_client="erigon";;
        *geth.yml* ) __el_volume='geth-eth1-data'; __el_client="geth";;
        *reth.yml* ) __el_volume='reth-el-data'; __el_client="reth";;
        *besu.yml* ) __el_volume='besu-eth1-data'; __el_client="besu";;
        *nethermind.yml* ) __el_volume='nm-eth1-data'; __el_client="nethermind";;
        * ) echo "You do not appear to be running an execution layer client. Nothing to do."; return;;
    esac

    if ! dodocker volume ls -q | grep -q "$(basename "$(realpath .)")[_-]${__el_volume}"; then
        echo "Did not find docker volume for ${__el_client}. Nothing to do."
        return
    fi

    echo "This will stop ${__el_client} and delete its database to force a resync."
    read -rp "WARNING - resync may take days. Do you wish to continue? (No/yes) " yn
    case $yn in
        [Yy][Ee][Ss] ) ;;
        * ) echo "Aborting."; exit 1;;
    esac

    echo "Stopping ${__el_client} container"
    docompose stop execution && docompose rm -f execution
    dodocker volume rm "$(dodocker volume ls -q -f "name=${__el_volume}")"
    echo ""
    echo "${__el_client} stopped and database deleted."
    echo ""
    echo "Restarting for resync."
    up
}

resync-consensus() {
    # Check for CL client
    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)

    case "${value}" in
        *lighthouse.yml* ) __cl_volume='lhbeacon-data'; __cl_client="lighthouse";;
        *lighthouse-cl-only.yml* ) __cl_volume='lhconsensus-data'; __cl_client="lighthouse";;
        *teku.yml* ) __cl_volume='wipe-db'; __cl_client="teku";;
        *teku-cl-only.yml* ) __cl_volume='tekuconsensus-data'; __cl_client="teku";;
        *nimbus.yml* ) __cl_volume='wipe-db'; __cl_client="nimbus";;
        *nimbus-cl-only.yml* ) __cl_volume='nimbus-consensus-data'; __cl_client="nimbus";;
        *lodestar.yml* | *lodestar-cl-only.yml* ) __cl_volume='lsconsensus-data'; __cl_client="lodestar";;
        *prysm.yml* ) __cl_volume='prysmbeacon-data'; __cl_client="prysm";;
        *prysm-cl-only.yml* ) __cl_volume='prysmconsensus-data'; __cl_client="prysm";;
        * ) echo "You do not appear to be running a consensus layer client. Nothing to do."; return;;
    esac

    if [ ! "${__cl_volume}" = "wipe-db" ] && ! dodocker volume ls -q | grep -q "$(basename "$(realpath .)")[_-]${__cl_volume}"; then
        echo "Did not find docker volume for ${__cl_client}. Nothing to do."
        return
    fi

    # Can we checkpoint sync?
    var="RAPID_SYNC_URL"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    echo "This will stop ${__cl_client} and delete its database to force a resync."
    if [ -z "${value}" ]; then
        read -rp "WARNING - RAPID_SYNC_URL not set, resync may take days. Do you wish to continue? (No/yes) " yn
    else
        read -rp "RAPID_SYNC_URL set, resync should finish in minutes. Do you wish to continue? (No/yes) " yn
    fi
    case $yn in
        [Yy][Ee][Ss] ) ;;
        * ) echo "Aborting."; exit 1;;
    esac

    echo "Stopping ${__cl_client} container"
    docompose stop consensus && docompose rm -f consensus
    if [ "${__cl_volume}" = "wipe-db" ]; then
      docompose run --rm wipe-db
    else
      dodocker volume rm "$(dodocker volume ls -q -f "name=${__cl_volume}")"
    fi
    echo ""
    echo "${__cl_client} stopped and database deleted."
    echo ""
    echo "Restarting for resync."
    up
}

attach-geth() {
    if [ ! -f "./${ENV_FILE}" ]; then
        echo "${ENV_FILE} configuration file not found, aborting."
        exit 1
    fi

    if ! grep -q '^COMPOSE_FILE=.*geth\.yml' "${ENV_FILE}" 2>/dev/null ; then
        echo "You do not appear to be using Geth, aborting."
        exit 1
    fi

    docompose exec -it execution bash -c "geth attach /var/lib/goethereum/geth.ipc"
}

prune-geth() {
    __non_interactive=0
    while :
    do
        if [ -z "${1+x}" ]; then
            break
        fi
        case "$1" in
            --non-interactive)
                __non_interactive=1
                shift
                ;;
            *)
                echo "Error: Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    if [ ! -f "./${ENV_FILE}" ]; then
        echo "${ENV_FILE} configuration file not found, aborting."
        exit 1
    fi

    if ! grep -q '^COMPOSE_FILE=.*geth\.yml' "${ENV_FILE}" 2>/dev/null ; then
        echo "You do not appear to be using Geth, aborting."
        exit 1
    fi

    # Check for archive node
    var="ARCHIVE_NODE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if [[ "${value}" = "true" ]]; then
        echo "Geth is an archive node: Aborting."
        return
    fi

    __docker_dir=$(dodocker system info --format '{{.DockerRootDir}}')
    __free_space=$(df -P "${__docker_dir}" | awk '/[0-9]%/{print $(NF-2)}')

    re='^[0-9]+$'
    if ! [[ "${__free_space}" =~ $re ]] ; then
        echo "Unable to determine free disk space. This is likely a bug."
        echo "df reports $(df -P "${__docker_dir}") and __free_space is ${__free_space}"
        return
    fi

    if [ "${__free_space}" -lt 41943040 ]; then
        echo "You do not have enough free disk space. Make sure this reads at least 40G free (Avail):"
        df -h "${__docker_dir}"
        echo ""
        echo "Aborting."
        exit 1
    fi

    rpc_line=$(grep '^EL_RPC_PORT=' "${ENV_FILE}")
    regex='^EL_RPC_PORT=([0-9]+)'
    if [[ ! "${rpc_line}" =~ ${regex} ]]; then
        echo "Unable to determine EL_RPC_PORT, aborting."
        exit 1
    else
        rpc_port="${BASH_REMATCH[1]}"
    fi

    sync_status=$(docompose exec -T execution wget -qO- "http://localhost:$rpc_port" --header 'Content-Type: application/json' --post-data '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}')
    exitstatus=$?
    if [ $exitstatus -ne 0 ]; then
        echo "Unable to connect to Geth: Is it running?"
        echo "Output: ${sync_status}"
        echo "Aborting."
        exit 1
    fi

    if [[ ! "${sync_status}" =~ "false" ]]; then
        echo "Geth is not done syncing yet. Sync status:"
        echo "${sync_status}"
        echo ""
        echo "Aborting."
        exit 1
    fi

    node_logs=$(docompose logs --no-color --tail 1000 execution)
    if [[ "${node_logs}" =~ "snapshot generation" && ! "${node_logs}" =~ "Generated state" ]]; then
        echo "Geth has not finished generating a state snapshot yet, aborting."
        exit 1
    fi

    regex='\[([0-9][0-9]-[0-9][0-9])\|([0-9][0-9]:[0-9][0-9]):[0-9.]*\][[:space:]]*Generated state'
    if [[ "${node_logs}" =~ $regex ]]; then
        snap_time=$(date -d "1970-${BASH_REMATCH[1]} ${BASH_REMATCH[2]}" +"%s")
        now_time=$(date +"%s")
        if [ $((snap_time+2100)) -gt "$now_time" ]; then
            echo "Please wait 35 minutes after snapshot generation finished. Aborting."
            exit 1
        fi
    fi

    if [ $__non_interactive = 0 ]; then
      while true; do
          read -rp "WARNING - this will stop Geth and prune its database. Do you wish to continue? (No/Yes) " yn
          case $yn in
              [Yy][Ee][Ss] ) break;;
              * ) echo "Aborting, no changes made"; exit 1;;
          esac
      done
    fi

    echo ""
    echo "Starting Geth prune"
    echo ""
    docompose run --rm set-prune-marker "touch /var/lib/goethereum/prune-marker"
    docompose stop execution && docompose rm -f execution
    start
    echo ""
    echo "Prune is running, you can observe it with './ethd logs -f execution'"
    echo ""
    echo "There should be three stages: \"Iterating state snapshot\", \"Pruning state data\", and \"Compacting database\". During \
the \"Compacting database\" stage it may not output logs for an hour or so, that is normal."
    echo ""
    echo "When prune is done, which takes 4-5 hours, Geth will automatically start again."
    echo ""
}

prune-nethermind() {
    __non_interactive=0
    while :
    do
        if [ -z "${1+x}" ]; then
            break
        fi
        case "$1" in
            --non-interactive)
                __non_interactive=1
                shift
                ;;
            *)
                echo "Error: Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done

    if [ ! -f "./${ENV_FILE}" ]; then
        echo "${ENV_FILE} configuration file not found, aborting."
        exit 1
    fi

    if ! grep -q '^COMPOSE_FILE=.*nethermind\.yml' "${ENV_FILE}" 2>/dev/null ; then
        echo "You do not appear to be using Nethermind, aborting."
        exit 1
    fi

    # Check for archive node
    var="ARCHIVE_NODE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if [[ "${value}" = "true" ]]; then
        echo "Nethermind is an archive node: Aborting."
        return
    fi

    __docker_dir=$(dodocker system info --format '{{.DockerRootDir}}')
    __free_space=$(df -P "${__docker_dir}" | awk '/[0-9]%/{print $(NF-2)}')

    re='^[0-9]+$'
    if ! [[ "${__free_space}" =~ $re ]] ; then
        echo "Unable to determine free disk space. This is likely a bug."
        echo "df reports $(df -P "${__docker_dir}") and __free_space is ${__free_space}"
        return
    fi

    if [ "${__free_space}" -lt 262144000 ]; then
        echo "You do not have enough free disk space. Make sure this reads at least 250G free (Avail):"
        df -h "${__docker_dir}"
        echo ""
        echo "Aborting."
        exit 1
    fi

    rpc_line=$(grep '^EL_RPC_PORT=' "${ENV_FILE}")
    regex='^EL_RPC_PORT=([0-9]+)'
    if [[ ! "${rpc_line}" =~ ${regex} ]]; then
        echo "Unable to determine EL_RPC_PORT, aborting."
        exit 1
    else
        rpc_port="${BASH_REMATCH[1]}"
    fi

    sync_status=$(docompose exec -T execution wget -qO- "http://localhost:$rpc_port" --header 'Content-Type: application/json' --post-data '{"jsonrpc":"2.0","method":"eth_syncing","params":[],"id":1}')
    exitstatus=$?
    if [ $exitstatus -ne 0 ]; then
        echo "Unable to connect to Nethermind: Is it running?"
        echo "Output: ${sync_status}"
        echo "Aborting."
        exit 1
    fi

    if [[ ! "${sync_status}" =~ "false" ]]; then
        echo "Nethermind is not done syncing yet. Sync status:"
        echo "${sync_status}"
        echo ""
        echo "Aborting."
        exit 1
    fi

    var="AUTOPRUNE_NM"
    auto_prune=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)

    if [ $__non_interactive = 0 ]; then
      while true; do
          if [ "${auto_prune}" = true ]; then
              echo "Nethermind should auto-prune below 350 GiB free. Check logs with \"./ethd logs -f --tail 500 execution | grep Full\" to see whether it is."
          fi
          read -rp "WARNING - this will prune Nethermind's database in the background. Do you wish to continue? (No/Yes) " yn
          case $yn in
              [Yy][Ee][Ss] ) break;;
              * ) echo "Aborting, no changes made"; exit 1;;
          esac
      done
    fi

    echo ""
    echo "Starting Nethermind prune"
    echo ""

    prune_result=$(docompose exec -T execution wget -qO- "http://localhost:1337" --header 'Content-Type: application/json' --post-data '{"jsonrpc":"2.0","method":"admin_prune","params":[],"id":1}')
    exitstatus=$?
    if [ $exitstatus -ne 0 ]; then
        echo "Unable to start prune, error code ${exitstatus}. This is likely a bug."
        echo "An attempt to run it returned this: ${prune_result}"
        echo 'The command attempted was: docker-compose run --rm set-prune-marker "curl -s --data {\\\"method\\\":\\\"admin_prune\\\",\\\"params\\\":[],\\\"id\\\":1,\\\"jsonrpc\\\":\\\"2.0\\\"} -H Content-Type:\ application/json http://execution:8545"'
        exit ${exitstatus}
    fi
    echo "Nethermind returns ${prune_result}"
    if [[ ! "${prune_result}" =~ "Starting" ]]; then
        echo "Unable to start prune. This is likely a bug."
        exit 1
    fi
    echo ""
    echo "Prune is running, you can observe it with \"./ethd logs -f --tail 500 execution | grep Full\""
    echo ""
    echo "Please do not restart the node or restart Nethermind until prune is done."
    echo ""
    echo "When prune is done, Nethermind will automatically re-start."
    echo ""
}

prep-keyimport() {
    set -Eeuo pipefail
    if [ ! -f "./${ENV_FILE}" ]; then
        echo "${ENV_FILE} configuration file not found, aborting."
        exit 1
    fi

    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
# Literal match intended
# shellcheck disable=SC2076
    if [[ ! "${value}" =~ "prysm.yml" ]] && [[ ! "${value}" =~ "lighthouse.yml" ]] && [[ ! "${value}" =~ "teku.yml" ]] \
       && [[ ! "${value}" =~ "nimbus.yml" ]] && [[ ! "${value}" =~ "lodestar.yml" ]] && [[ ! "${value}" =~ "vc-only.yml" ]]; then
        echo "You do not appear to be running a validator client. Aborting."
        exit 1
    fi

    __prysm=0
    __path=''
    __non_interactive=0
    if grep -q '^COMPOSE_FILE=.*prysm.*\.yml' "${ENV_FILE}" 2>/dev/null ; then
        __prysm=1
    fi

    while :
    do
        if [ -z "${1+x}" ]; then
            break
        fi
        case "$1" in
            --path)
                if [ -z "${2+x}" ]; then
                    echo "--path requires a directory path, aborting"
                    exit 1
                fi
                if [ ! -d "$2" ]; then
                    echo "$2 is not a directory"
                    exit 1
                fi
                if [ "$(realpath "$2")" = "$(realpath ".eth/validator_keys")" ]; then
                    echo "$2 is the default path, doing nothing special"
                    shift 2
                    continue
                fi
                IFS=$'\n'
                files=$(find "$2" -maxdepth 1 -name '*.json')
                # Unset restores default
                unset IFS
                if [ -z "$files" ]; then
                    echo "No .json files found in $2, aborting"
                    exit 1
                fi
                IFS=$'\n'
                files=$(find ./.eth/validator_keys -maxdepth 1 -name '*.json')
                # Unset restores default
                unset IFS
                if [ -n "$files" ]; then
                    ${__as_owner} mkdir -p ./.eth/validator_keys/keybackup
                    ${__as_owner} mv -uf ./.eth/validator_keys/*.json ./.eth/validator_keys/keybackup
                    ${__as_owner} rm -f ./.eth/validator_keys/*.json
                    echo "Moved existing json files to .eth/validator_keys/keybackup"
                fi
                ${__as_owner} cp "$2"/*.json .eth/validator_keys/
                shift 2
                ;;
            --non-interactive)
                if [ -z "${KEYSTORE_PASSWORD+x}" ]; then
                    echo "KEYSTORE_PASSWORD not set or empty, aborting"
                    exit 1
                fi
                __non_interactive=1
                shift
                ;;
            *)
                echo "Error: Unknown option: $1" >&2
                exit 1
                ;;
        esac
    done
}

__i_haz_ethdo() {
    if [ ! -f ".env" ]; then
        echo "eth-docker has not been configured. Please run ./ethd config first."
        exit 1
    fi
    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
# Literal match intended
# shellcheck disable=SC2076
    if [[ ! "${value}" =~ "ethdo.yml" ]]; then
        echo "Please edit the .env file and make sure \":ethdo.yml\" is added to the \"COMPOSE_FILE\" line"
        echo "For example, \"nano .env\" will open the nano text editor with the \".env\" file loaded."
        echo "Without it, this step cannot be run"
        echo
        read -rp "Do you want me to make this change for you? (n/y)" yn
        case $yn in
            [Yy] );;
            * ) exit 1;;
        esac
        if [ -n "${value}" ]; then
          COMPOSE_FILE="${value}:ethdo.yml"
        else
          COMPOSE_FILE="ethdo.yml"
          echo "You do not have a CL in eth-docker. Please make sure CL_NODE in .env points at an available one"
        fi
        set_value_in_env
        echo "Your COMPOSE_FILE now reads ${COMPOSE_FILE}"
    fi
}

__i_haz_web3signer() {
    if [ ! -f ".env" ]; then
        echo "eth-docker has not been configured. Please run ./ethd config first."
        exit 1
    fi

    var="WEB3SIGNER"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if [ ! "${value}" = "true" ]; then
        return
    fi

    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
# Literal match intended
# shellcheck disable=SC2076
    if [[ ! "${value}" =~ "web3signer.yml" ]]; then
        echo "WEB3SIGNER=true in .env, but web3signer.yml is not in use"
        echo "Please edit the .env file and make sure \":web3signer.yml\" is added to the \"COMPOSE_FILE\" line"
        echo "For example, \"nano .env\" will open the nano text editor with the \".env\" file loaded."
        echo "Without it, ./ethd keys cannot be run"
        echo
        read -rp "Do you want me to make this change for you? (n/y)" yn
        case $yn in
            [Yy] );;
            * ) exit 1;;
        esac
        if [ -n "${value}" ]; then
          COMPOSE_FILE="${value}:web3signer.yml"
        else
          echo "You do not have a validator client in eth-docker. web3signer cannot be used without one."
          exit 1
        fi
        set_value_in_env
        echo "Your COMPOSE_FILE now reads ${COMPOSE_FILE}"
    fi
}

__keys_usage() {
    echo "Call keymanager with an ACTION, one of:"
    echo "  list"
    echo "     Lists the public keys of all validators currently loaded into your validator client"
    echo "  import"
    echo "      Import all keystore*.json in .eth/validator_keys while loading slashing protection data"
    echo "      in slashing_protection*.json files that match the public key(s) of the imported validator(s)"
    echo "  delete 0xPUBKEY | all"
    echo "      Deletes the validator with public key 0xPUBKEY from the validator client, and exports its"
    echo "      slashing protection database. \"all\" deletes all detected validators instead"
    echo "  register"
    echo "      For use with web3signer only: Re-register all keys in web3signer with the validator client"
    echo
    echo "  get-recipient 0xPUBKEY"
    echo "      List fee recipient set for the validator with public key 0xPUBKEY"
    echo "      Validators will use FEE_RECIPIENT in .env by default, if not set individually"
    echo "  set-recipient 0xPUBKEY 0xADDRESS"
    echo "      Set individual fee recipient for the validator with public key 0xPUBKEY"
    echo "  delete-recipient 0xPUBKEY"
    echo "      Delete individual fee recipient for the validator with public key 0xPUBKEY"
    echo
    echo "  get-gas 0xPUBKEY"
    echo "      List execution gas limit set for the validator with public key 0xPUBKEY"
    echo "      Validators will use the client's default, if not set individually"
    echo "  set-gas 0xPUBKEY amount"
    echo "      Set individual execution gas limit for the validator with public key 0xPUBKEY"
    echo "  delete-gas 0xPUBKEY"
    echo "      Delete individual execution gas limit for the validator with public key 0xPUBKEY"
    echo
    echo "  get-api-token"
    echo "      Print the token for the keymanager API running on port ${KEY_API_PORT:-7500}."
    echo "      This is also the token for the Prysm Web UI"
    echo
    echo "  create-prysm-wallet"
    echo "      Create a new Prysm wallet to store keys in"
    echo "  get-prysm-wallet"
    echo "      Print Prysm's wallet password"
    echo
    echo "  prepare-address-change"
    echo "      Create an offline-preparation.json with ethdo"
    echo "  send-address-change"
    echo "      Send a change-operations.json with ethdo, setting the withdrawal address"
    echo
    echo "  sign-exit from-keystore [--offline]"
    echo "      Create pre-signed exit messages with ethdo, from keystore files in ./.eth/validator_keys"
}

keys() {
    if [[ "$#" -eq 0 || "$1" == "help" || "$1" == "-h" || "$1" == "--help" ]]; then
        __keys_usage
        return
    fi

    __i_haz_web3signer

    __owner_uid=$(id -u "${OWNER}")
    if [ "${1:-}" = "import" ]; then
        shift
        prep-keyimport "$@"
        if [ ${__non_interactive} = 1 ]; then
            docompose run --rm -e OWNER_UID="${__owner_uid}" validator-keys import --non-interactive
        else
            docompose run --rm -e OWNER_UID="${__owner_uid}" validator-keys import
        fi
    elif [ "${1:-}" = "create-prysm-wallet" ]; then
        var="COMPOSE_FILE"
        value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
# Literal match intended
# shellcheck disable=SC2076
        if [[ ! "${value}" =~ "prysm.yml" ]] && [[ ! "${value}" =~ "prysm-vc-only.yml" ]]; then
            echo "You do not appear to be using a Prysm validator. Aborting."
            exit 1
        fi
        if docompose run --rm create-wallet; then
            docompose stop validator
            docompose rm --force validator
            up
        fi
    elif [ "${1:-}" = "prepare-address-change" ]; then
        __i_haz_ethdo
        echo "Generating offline prep file"
        docompose run --rm ethdo validator credentials set --prepare-offline
        exitstatus=$?
        if [ "${exitstatus}" -ne 0 ]; then
            echo "Running ethdo failed, unfortunately. Is the CL running and synced?"
            echo "Please try again after fixing root cause. Aborting."
            return 1
        fi
        echo
        echo "Downloading ethdo"
        REPO="wealdtech/ethdo"; \
        wget -q -O- https://api.github.com/repos/${REPO}/releases/latest | grep "browser_download_url.*linux-amd64.tar.gz" \
        | head -1 \
        | cut -d : -f 2,3 \
        | tr -d \" \
        | wget -qi- -O- \
        | ${__as_owner} tar zxf - -C ./.eth/ethdo/ \
        || echo "-> Could not download the latest version of '${REPO}' for amd64."
        ${__as_owner} mkdir -p ./.eth/ethdo/arm64
        wget -q -O- https://api.github.com/repos/${REPO}/releases/latest | grep "browser_download_url.*linux-arm64.tar.gz" \
        | head -1 \
        | cut -d : -f 2,3 \
        | tr -d \" \
        | wget -qi- -O- \
        | ${__as_owner} tar zxf - -C ./.eth/ethdo/arm64 \
        || echo "-> Could not download the latest version of '${REPO}' for arm64."
        ${__as_owner} mv ./.eth/ethdo/arm64/ethdo ./.eth/ethdo/ethdo-arm64
        ${__as_owner} rm -rf ./.eth/ethdo/arm64
        echo
        echo "Copy the contents of ./.eth/ethdo to a USB drive, and prepare a Linux Live USB to safely enter your mnemonic."
        echo "Please see https://eth-docker.net/Support/ChangingWithdrawalCredentials for details"
    elif [ "${1:-}" = "send-address-change" ]; then
        __i_haz_ethdo
        docompose run --rm ethdo validator credentials set
    elif [ "${1:-}" = "sign-exit" ] && [ "${2:-}" = "from-keystore" ]; then
        __i_haz_ethdo

        if echo "$@" | grep -q '.*--offline.*' 2>/dev/null ; then
          __offline="--offline"
        else
          __offline=""
       fi

        __non_interactive=0
        if echo "$@" | grep -q '.*--non-interactive.*' 2>/dev/null ; then
          __non_interactive=1
        fi

        if [ ${__non_interactive} = 1 ]; then
            __password="${KEYSTORE_PASSWORD}"
            __justone=1
        else
            __num_files=$(find .eth/validator_keys -maxdepth 1 -type f -name 'keystore*.json' | wc -l)
            if [ "$__num_files" -eq 0 ]; then
                echo "No keystore*.json files found in .eth/validator_keys/"
                echo "Nothing to do"
                exit 0
            fi

            if [ "$__num_files" -gt 1 ]; then
                while true; do
                    read -rp "Do all validator keys have the same password? (y/n) " yn
                    case $yn in
                        [Yy]* ) __justone=1; break;;
                        [Nn]* ) __justone=0; break;;
                        * ) echo "Please answer yes or no.";;
                    esac
                done
            else
                __justone=1
            fi
            if [ "${__justone}" -eq 1 ]; then
                while true; do
                    read -srp "Please enter the password for your validator key(s): " __password
                    echo
                    read -srp "Please re-enter the password: " __password2
                    echo
                    if [ "${__password}" == "${__password2}" ]; then
                        break
                    else
                        echo "The two entered passwords do not match, please try again."
                        echo
                    fi
                done
                echo
            fi
        fi

        created=0
        failed=0
        mkdir -p .eth/exit_messages
        for __keyfile in .eth/validator_keys/keystore-*.json; do
            [ -f "${__keyfile}" ] || continue # Should always evaluate true - just in case
            if [ "${__justone}" -eq 0 ]; then
                while true; do
                    read -srp "Please enter the password for your validator key stored in ${__keyfile}: " __password
                    echo
                    read -srp "Please re-enter the password: " __password2
                    echo
                    if [ "${__password}" == "${__password2}" ]; then
                        break
                    else
                        echo "The two entered passwords do not match, please try again."
                        echo
                    fi
                    echo
                done
            fi

            __pubkey="$(sed -E 's/.*"pubkey":\s*"([0-9a-fA-F]+)".*/\1/' < "${__keyfile}")"
            if [ -z "$__pubkey" ]; then
                echo "Unable to read public key from ${__keyfile}. Is it the right format?"
                continue
            else
                __pubkey="0x${__pubkey}"
            fi
            # __offline may be empty, don't quote it
            # shellcheck disable=SC2086
            __json=$(docompose run --rm ethdo validator exit --validator "${__keyfile}" --json --timeout 2m --passphrase "${__password}" ${__offline})
            exitstatus=$?
            if [ "${exitstatus}" -eq 0 ]; then
              echo "${__json}" >".eth/exit_messages/${__pubkey::10}--${__pubkey:90}-exit.json"
              exitstatus=$?
              if [ "${exitstatus}" -eq 0 ]; then
                echo "Creating an exit message for validator ${__pubkey} into file ./.eth/exit_messages/${__pubkey::10}--${__pubkey:90}-exit.json succeeded"
                (( created++ ))
              else
                echo "Error writing exit json to file ./.eth/exit_messages/${__pubkey::10}--${__pubkey:90}-exit.json"
                (( failed++ ))
              fi
            else
                echo "Creating an exit message for validator ${__pubkey} from file ${__keyfile} failed"
                (( failed++ ))
            fi
        done
        echo
        echo "Created pre-signed exit messages for ${created} validators"
        if [ "${created}" -gt 0 ]; then
          echo "You can find them in ./.eth/exit_messages"
        fi
        if [ "${failed}" -gt 0 ]; then
          echo "Failed for ${failed} validators"
        fi
    else
        docompose run --rm -e OWNER_UID="${__owner_uid}" validator-keys "$@"
    fi
}

keyimport() {
    echo "The legacy keyimport command has been removed."
    echo "Please try ./ethd keys import instead."
}

upgrade() {
  update
}

start() {
    docompose up -d --remove-orphans
}

up() {
    start
}

run() {
    start
}

stop() {
    docompose down --remove-orphans
}

down() {
    stop
}

terminate() {
    while true; do
        read -rp "WARNING - this action will destroy all data stores for this Ethereum node. Do you wish to continue? (No/Yes) " yn
        case $yn in
            [Yy][Ee][Ss] ) break;;
            * ) echo "Aborting, no changes made"; exit 1;;
        esac
    done

    down
# In this case I want the word splitting, so rm can remove all volumes
# shellcheck disable=SC2046
    dodocker volume rm $(dodocker volume ls -q -f "name=$(basename "$(realpath .)")")
    echo ""
    echo "All containers stopped and all volumes deleted"
    echo ""
}

restart() {
    stop
    start
}

logs() {
    docompose logs "$@"
}

cmd() {
    docompose "$@"
}

query_network() {
    # Mainnet or Testnet network
    NETWORK=$(whiptail --notags --title "Select Network" --menu \
    "Which network do you want to run on?" 12 60 5 \
    "goerli" "Grli (n Prater) Testnet" \
    "mainnet" "Ethereum Mainnet" \
    "gnosis" "Gnosis Chain (n xDai)" \
    "sepolia" "Sepolia Testnet (permissioned validators)" 3>&1 1>&2 2>&3)

    case "${NETWORK}" in
       "mainnet")
           echo "You chose to run on Ethereum mainnet"
           ;;
       "gnosis")
           echo "You chose to run on Gnosis Chain"
           ;;
       "goerli" | "sepolia" | "zhejiang" )
           echo "You chose to run on ${NETWORK} testnet"
           ;;
       *)
           echo "You chose Cancel"
           exit 1
           ;;
    esac
}

query_deployment() {
    if [ "${NETWORK}" = "gnosis" ]; then
      __deployment=$(whiptail --notags --title "Select deployment type" --menu \
      "What kind of deployment do you want to run?" 11 80 3 \
      "node" "Ethereum node - consensus, execution and validator client" \
      "rpc" "Ethereum RPC node - consensus and execution client" 3>&1 1>&2 2>&3)
    elif uname -a | grep -q aarch64; then
      __deployment=$(whiptail --notags --title "Select deployment type" --menu \
      "What kind of deployment do you want to run?" 11 80 4 \
      "node" "Ethereum node - consensus, execution and validator client" \
      "rocket" "Validator client only - integrate with RocketPool" \
      "rpc" "Ethereum RPC node - consensus and execution client" 3>&1 1>&2 2>&3)
    else
      __deployment=$(whiptail --notags --title "Select deployment type" --menu \
      "What kind of deployment do you want to run?" 12 80 5 \
      "node" "Ethereum node - consensus, execution and validator client" \
      "rocket" "Validator client only - integrate with RocketPool" \
      "blox" "Blox SSV node - consensus, execution and ssv-node" \
      "rpc" "Ethereum RPC node - consensus and execution client" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your deployment choice is: ${__deployment}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_validator_client() {
    if [ "${NETWORK}" = "gnosis" ]; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
      "Which validator client do you want to run?" 9 65 3 \
      "lighthouse-vc-only.yml" "Lighthouse validator client" \
      "teku-vc-only.yml" "Teku validator client" \
      "nimbus-vc-only.yml" "Nimbus validator client" 3>&1 1>&2 2>&3)
    elif [ "${__deployment}" = "rocket" ]; then
        if uname -a | grep -q aarch64; then
          CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
          "Which validator client do you want to run?" 9 65 3 \
          "lighthouse-vc-only.yml" "Lighthouse validator client" \
          "teku-vc-only.yml" "Teku validator client" \
          "lodestar-vc-only.yml" "Lodestar validator client" \
          "nimbus-vc-only.yml" "Nimbus validator client" 3>&1 1>&2 2>&3)
        else
          CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
          "Which validator client do you want to run?" 9 65 3 \
          "teku-vc-only.yml" "Teku validator client" \
          "lighthouse-vc-only.yml" "Lighthouse validator client" \
          "lodestar-vc-only.yml" "Lodestar validator client" \
          "nimbus-vc-only.yml" "Nimbus validator client" 3>&1 1>&2 2>&3)
        fi
    elif uname -a | grep -q aarch64; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
      "Which validator client do you want to run?" 9 65 3 \
      "lighthouse-vc-only.yml" "Lighthouse validator client" \
      "teku-vc-only.yml" "Teku validator client" \
      "lodestar-vc-only.yml" "Lodestar validator client" \
      "nimbus-vc-only.yml" "Nimbus validator client" 3>&1 1>&2 2>&3)
    else
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select validator client" --menu \
      "Which validator client do you want to run?" 11 65 5 \
      "teku-vc-only.yml" "Teku validator client" \
      "lighthouse-vc-only.yml" "Lighthouse validator client" \
      "lodestar-vc-only.yml" "Lodestar validator client" \
      "nimbus-vc-only.yml" "Nimbus validator client" \
      "prysm-vc-only.yml" "Prysm validator client" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your validator client file is:" "${CONSENSUS_CLIENT}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_consensus_client() {
    if [ "${NETWORK}" = "gnosis" ]; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 10 65 3 \
      "lighthouse.yml" "Lighthouse (Rust) - consensus and validator client" \
      "teku.yml" "Teku (Java) - consensus and validator client" \
      "nimbus.yml" "Nimbus (Nim) - consensus and validator client" 3>&1 1>&2 2>&3)
    elif [ "${NETWORK}" = "zhejiang" ]; then
      CONSENSUS_CLIENT=lodestar.yml
    elif uname -a | grep -q aarch64; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 10 65 3 \
      "nimbus.yml" "Nimbus (Nim) - consensus and validator client" \
      "lodestar.yml" "Lodestar (Javascript) - consensus and validator client" \
      "lighthouse.yml" "Lighthouse (Rust) - consensus and validator client" \
      "teku.yml" "Teku (Java) - consensus and validator client" 3>&1 1>&2 2>&3)
    else
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 12 65 5 \
      "teku.yml" "Teku (Java) - consensus and validator client" \
      "lighthouse.yml" "Lighthouse (Rust) - consensus and validator client" \
      "nimbus.yml" "Nimbus (Nim) - consensus and validator client" \
      "lodestar.yml" "Lodestar (Javascript) - consensus and validator client" \
      "prysm.yml" "Prysm (Go) - consensus and validator client" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your consensus client file is:" "${CONSENSUS_CLIENT}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_consensus_only_client() {
    if [ "${NETWORK}" = "gnosis" ]; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 10 65 3 \
      "lighthouse-cl-only.yml" "Lighthouse (Rust) - consensus client" \
      "teku-cl-only.yml" "Teku (Java) - consensus client" \
      "nimbus-cl-only.yml" "Nimbus (Nim) - consensus client" 3>&1 1>&2 2>&3)
    elif uname -a | grep -q aarch64; then
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 10 65 3 \
      "nimbus-cl-only.yml" "Nimbus (Nim) - consensus client" \
      "lodestar-cl-only.yml" "Lodestar (Javascript) - consensus client" \
      "lighthouse-cl-only.yml" "Lighthouse (Rust) - consensus client" \
      "teku-cl-only.yml" "Teku (Java) - consensus client" 3>&1 1>&2 2>&3)
    else
      CONSENSUS_CLIENT=$(whiptail --notags --title "Select consensus client" --menu \
      "Which consensus client do you want to run?" 12 65 5 \
      "teku-cl-only.yml" "Teku (Java) - consensus client" \
      "lighthouse-cl-only.yml" "Lighthouse (Rust) - consensus client" \
      "nimbus-cl-only.yml" "Nimbus (Nim) - consensus client" \
      "lodestar-cl-only.yml" "Lodestar (Javascript) - consensus client" \
      "prysm-cl-only.yml" "Prysm (Go) - consensus client" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your consensus client file is:" "${CONSENSUS_CLIENT}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_custom_execution_client() {
    if [ "${__minty_fresh}" -eq 1 ]; then
        EL_CUSTOM_NODE=""
        JWT_SECRET=""
    else
        var="EL_NODE"
        EL_CUSTOM_NODE=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
        var="JWT_SECRET"
        JWT_SECRET=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    fi
    EL_CUSTOM_NODE=$(whiptail --title "Configure custom execution client" --inputbox "What is the URL for your custom execution client? (right-click to paste)" 10 60 "${EL_CUSTOM_NODE}" 3>&1 1>&2 2>&3)

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your custom execution client is: $EL_CUSTOM_NODE"
    else
        echo "You chose Cancel."
        exit 1
    fi

    while true; do
        JWT_SECRET=$(whiptail --title "Configure JWT secret" --inputbox "What is the JWT secret shared with the execution client? (right-click to paste)" 10 60 "${JWT_SECRET}" 3>&1 1>&2 2>&3)

        exitstatus=$?
        if [ $exitstatus -eq 0 ]; then
            if [[ ${#JWT_SECRET} -eq 64 ]]; then
              echo "JWT Secret set. Please make sure it matches on CL and EL."
              break
            else
              whiptail --msgbox "The JWT secret needs to be exactly 32 bytes, 64 hex characters long. You can try again or Cancel on the next screen." 10 75
            fi
        else
            echo "You chose Cancel."
            exit 1
        fi
    done
}

query_execution_client() {
    if [ "${NETWORK}" = "gnosis" ]; then
      EXECUTION_CLIENT=$(whiptail --notags --title "Select execution client" --menu \
      "Which execution client do you want to run?" 9 60 2 \
      "nethermind.yml" "Nethermind (.NET)" \
      "erigon.yml" "Erigon (Go)" 3>&1 1>&2 2>&3)
    elif [ "${NETWORK}" = "zhejiang" ]; then
      EXECUTION_CLIENT=nethermind.yml
    elif uname -a | grep -q aarch64; then
      EXECUTION_CLIENT=$(whiptail --notags --title "Select execution client" --menu \
      "Which execution client do you want to run?" 9 60 3 \
      "besu.yml" "Besu (Java)" \
      "nethermind.yml" "Nethermind (.NET)" \
      "geth.yml" "Geth (Go)" 3>&1 1>&2 2>&3)
    else
      EXECUTION_CLIENT=$(whiptail --notags --title "Select execution client" --menu \
      "Which execution client do you want to run?" 12 60 5 \
      "nethermind.yml" "Nethermind (.NET)" \
      "besu.yml" "Besu (Java)" \
      "geth.yml" "Geth (Go)" \
      "erigon.yml" "Erigon (Go)" \
      "NONE" "Custom - Distributed" 3>&1 1>&2 2>&3)
    fi

    exitstatus=$?
    if [ $exitstatus -ne 0 ]; then
        echo "You chose Cancel."
        exit 1
    fi

    if [ "${EXECUTION_CLIENT}" == "NONE" ]; then
        unset EXECUTION_CLIENT
        query_custom_execution_client
        EL_NODE="${EL_CUSTOM_NODE}"
    else
        echo "Your execution client file is:" "${EXECUTION_CLIENT}"
	if [[ "${CONSENSUS_CLIENT}" =~ "nimbus-" ]]; then
            EL_NODE="http://execution:8551"
	else
# This gets used, but shellcheck doesn't recognize that
# shellcheck disable=SC2034
            EL_NODE="http://execution:8551"
	fi
	if [ "${EXECUTION_CLIENT}" = "erigon.yml" ]; then
	    echo "Please remember to set your EL_WS_PORT to match EL_RPC_PORT for Erigon"
	fi
    fi
}

query_grafana() {
    if (whiptail --title "Grafana" --yesno "Do you want to use Grafana dashboards?" 10 60) then
        if [[ "$OSTYPE" == "darwin"* ]]; then
        # macOS doesn't do well with / bind mount - leave node-exporter, cadvisor and loki/promtail off by default
            GRAFANA_CLIENT="grafana-rootless.yml:grafana-shared.yml"
        else
            GRAFANA_CLIENT="grafana.yml:grafana-shared.yml"
        fi
    else
        unset GRAFANA_CLIENT
    fi
}

query_remote_beacon() {
    if [ "${__minty_fresh}" -eq 1 ]; then
        if [ "${__deployment}" = "rocket" ]; then
            REMOTE_BEACON="http://eth2:5052"
        else
            REMOTE_BEACON=""
        fi
    else
        var="CL_NODE"
        REMOTE_BEACON=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    fi
    REMOTE_BEACON=$(whiptail --title "Configure remote consensus client" --inputbox "What is the URL for your remote consensus client? (right-click to paste)" 10 60 "${REMOTE_BEACON}" 3>&1 1>&2 2>&3)

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your remote consensus client is:" "${REMOTE_BEACON}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_checkpoint_beacon() {
    var="RAPID_SYNC_URL"
    RAPID_SYNC_URL=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if [ -z "${RAPID_SYNC_URL}" ]; then
        case "${NETWORK}" in
            "sepolia")
                RAPID_SYNC_URL="https://sepolia.beaconstate.info"
                ;;
            "goerli")
                RAPID_SYNC_URL="https://goerli.beaconstate.info"
                ;;
            "mainnet")
                RAPID_SYNC_URL="https://beaconstate.info"
                ;;
            "gnosis")
                RAPID_SYNC_URL="https://checkpoint.gnosischain.com/"
                ;;
            "zhejiang")
                RAPID_SYNC_URL="https://checkpointz.zhejiang.ethpandaops.io/"
                ;;
            *)
                RAPID_SYNC_URL=""
                ;;
        esac
    fi

    RAPID_SYNC_URL=$(whiptail --title "Configure checkpoint URL" --inputbox "What is the URL for your checkpoint provider? (right-click to paste)" 10 60 "${RAPID_SYNC_URL}" 3>&1 1>&2 2>&3)

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "Your checkpoint URL is:" "${RAPID_SYNC_URL}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_graffiti() {
    var="GRAFFITI"
    GRAFFITI=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)

    GRAFFITI=$(whiptail --title "Configure Graffiti" --inputbox "What Graffiti do you want to send with your blocks? (up to 32 characters)" 10 37 "${GRAFFITI}" 3>&1 1>&2 2>&3)

    exitstatus=$?
    if [ $exitstatus -eq 0 ]; then
        echo "your Graffiti is:" "${GRAFFITI}"
    else
        echo "You chose Cancel."
        exit 1
    fi
}

query_rapid_sync() {
    if (whiptail --title "Checkpoint Sync" --yesno "Do you want to use CL rapid sync with remote checkpoint?" 10 60) then
        query_checkpoint_beacon
    fi
}

query_coinbase() {
    var="FEE_RECIPIENT"
    FEE_RECIPIENT=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)

    while true; do
        if [ "${__deployment}" = rpc ]; then
            FEE_RECIPIENT=$(whiptail --title "Configure fee recipient" --inputbox "What is the fallback fee recipient address? Yes even on an RPC node. Can be any address at all. (right-click to paste, CANNOT be an ENS)" 10 60 "${FEE_RECIPIENT}" 3>&1 1>&2 2>&3)
        else
            FEE_RECIPIENT=$(whiptail --title "Configure rewards address" --inputbox "What is the address you want transaction rewards to be sent to by default? (right-click to paste, CANNOT be an ENS)" 10 60 "${FEE_RECIPIENT}" 3>&1 1>&2 2>&3)
        fi

        exitstatus=$?
        if [ $exitstatus -eq 0 ]; then
            if [[ ${FEE_RECIPIENT} == 0x* && ${#FEE_RECIPIENT} -eq 42 ]]; then
              echo "Your rewards address is: ${FEE_RECIPIENT}"
              break
            else
              whiptail --msgbox "${FEE_RECIPIENT} is not a valid ETH address. You can try again or Cancel on the next screen.\n\nThe client will not start successfully until a valid ETH rewards address has been set." 16 75
            fi
        else
            echo "You chose Cancel."
            if [ $__during_update -eq 1 ]; then
                echo
                echo "Please make requested changes manually or run \"./ethd update\" again"
                echo "before running \"./ethd up\"."
                echo
                echo "Without a FEE_RECIPIENT set in \".env\", containers will not"
                echo "start successfully. Already running containers will keep running with the"
                echo "old configuration until you are ready to restart them."
            fi
            echo
            # If this is called by an older version of ethd, envmigrate
            # is in its own bash instance: Need to kill the ethd parent
# shellcheck disable=SC2009
            if ps $PPID | grep -q "ethd"; then
                kill $PPID
            fi
            exit 1
        fi
    done
}

query_mev() {
    if [ "${NETWORK}" = "zhejiang" ] || [ "${NETWORK}" = "gnosis" ]; then
        return
    fi
    var="MEV_BOOST"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    if (whiptail --title "MEV Boost" --yesno "Do you want to use MEV Boost?" 10 60) then
        MEV_BOOST="true"
        if [ "${value}" = "true" ]; then
            var="MEV_RELAYS"
            MEV_RELAYS=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
        else
            case "${NETWORK}" in
                "sepolia")
                    MEV_RELAYS=https://0x845bd072b7cd566f02faeb0a4033ce9399e42839ced64e8b2adcfc859ed1e8e1a5a293336a49feac6d9a5edb779be53a@boost-relay-sepolia.flashbots.net
                    ;;
                "goerli")
                    MEV_RELAYS=https://0xafa4c6985aa049fb79dd37010438cfebeb0f2bd42b115b89dd678dab0670c1de38da0c4e9138c9290a398ecd9a0b3110@boost-relay-goerli.flashbots.net,\
https://0x821f2a65afb70e7f2e820a925a9b4c80a159620582c1766b1b09729fec178b11ea22abb3a51f07b288be815a1a2ff516@bloxroute.max-profit.builder.goerli.blxrbdn.com,\
https://0x8f7b17a74569b7a57e9bdafd2e159380759f5dc3ccbd4bf600414147e8c4e1dc6ebada83c0139ac15850eb6c975e82d0@builder-relay-goerli.blocknative.com,\
https://0xaa1488eae4b06a1fff840a2b6db167afc520758dc2c8af0dfb57037954df3431b747e2f900fe8805f05d635e9a29717b@relay-goerli.edennetwork.io,\
https://0xb1559beef7b5ba3127485bbbb090362d9f497ba64e177ee2c8e7db74746306efad687f2cf8574e38d70067d40ef136dc@relay-stag.ultrasound.money,\
https://0xab78bf8c781c58078c3beb5710c57940874dd96aef2835e7742c866b4c7c0406754376c2c8285a36c630346aa5c5f833@goerli.aestus.live,\
https://0xa6bcad37b5d647152a93c2807d8a56055f1e0d7480eb6505d46edc21593e400f0f13738bf2e892f85946234629a3036a@goerli.agnostic-relay.net
                    ;;
                "mainnet")
                    MEV_RELAYS=https://0xac6e77dfe25ecd6110b8e780608cce0dab71fdd5ebea22a16c0205200f2f8e2e3ad3b71d3499c54ad14d6c21b41a37ae@boost-relay.flashbots.net,\
https://0x8b5d2e73e2a3a55c6c87b8b6eb92e0149a125c852751db1422fa951e42a09b82c142c3ea98d0d9930b056a3bc9896b8f@bloxroute.max-profit.blxrbdn.com,\
https://0x9000009807ed12c1f08bf4e81c6da3ba8e3fc3d953898ce0102433094e5f22f21102ec057841fcb81978ed1ea0fa8246@builder-relay-mainnet.blocknative.com,\
https://0xb3ee7afcf27f1f1259ac1787876318c6584ee353097a50ed84f51a1f21a323b3736f271a895c7ce918c038e4265918be@relay.edennetwork.io,\
https://0xa1559ace749633b997cb3fdacffb890aeebdb0f5a3b6aaa7eeeaf1a38af0a8fe88b9e4b1f61f236d2e64d95733327a62@relay.ultrasound.money,\
https://0xa15b52576bcbf1072f4a011c0f99f9fb6c66f3e1ff321f11f461d15e31b1cb359caa092c71bbded0bae5b5ea401aab7e@aestus.live,\
https://0xa7ab7a996c8584251c8f925da3170bdfd6ebc75d50f5ddc4050a6fdc77f2a3b5fce2cc750d0865e05d7228af97d69561@agnostic-relay.net
                    ;;
                *)
                    MEV_RELAYS=""
                    ;;
            esac
        fi
        MEV_RELAYS=$(whiptail --title "Configure MEV relays" --inputbox "What MEV relay(s) do you want to use? (right-click to paste)" 10 60 "${MEV_RELAYS}" 3>&1 1>&2 2>&3)

        exitstatus=$?
        if [ $exitstatus -eq 0 ]; then
            echo "Your MEV relay(s): ${MEV_RELAYS}"
        else
            echo "You chose Cancel."
            exit 0
        fi
    else
        MEV_BOOST="false"
        MEV_RELAYS=""
    fi
}

set_value_in_env() {
    # Assumes that "var" has been set to the name of the variable to be changed
    if [ "${!var+x}" ]; then
        if ! grep -qF "${var}" "${ENV_FILE}" 2>/dev/null ; then
            echo "${var}=${!var}" >> "${ENV_FILE}"
        else
            sed -i'.original' -e "s~^\(${var}\s*=\s*\).*$~\1${!var}~" "${ENV_FILE}"
        fi
    fi
}

config() {
    check_for_snap
    if [[ "$__distro" = "ubuntu" ]]; then
      __major_version=$(lsb_release -r | cut -d: -f2 | sed s/'^\t'// | cut -d. -f1)
      if [ "${__major_version}" -lt 20 ]; then
         echo
         echo "Ubuntu ${__major_version} is older than the recommended versions 22.04 or 20.04"
         echo
      fi
    fi
    # Do not track changes to ext-network.yml
    ${__as_owner} git update-index --assume-unchanged ext-network.yml
    # Create ENV file if needed
    if ! [[ -f "${ENV_FILE}" ]]; then
        ENV_TEMPLATE="default.env"

        echo "Your configuration file template is:" "${ENV_TEMPLATE}"

        ${__as_owner} cp "${ENV_TEMPLATE}" "${ENV_FILE}"
        __minty_fresh=1
    else
        __minty_fresh=0
    fi

    query_network
    query_deployment
    case "${__deployment}" in
      "node")
        query_consensus_client
        ;;
      "validator" | "rocket")
        query_validator_client
        ;;
      "blox")
        if [ ! -f "./blox-ssv-config.yaml" ]; then
            ${__as_owner} cp ./blox-ssv-config-sample.yaml ./blox-ssv-config.yaml
        fi
        query_consensus_only_client
        ;;
      "rpc")
        query_consensus_only_client
        ;;
      *)
        echo "Unknown deployment ${__deployment}, this is a bug."
        exit 1
        ;;
    esac

    MEV_BOOST=false
# I do mean to match literally
# shellcheck disable=SC2076
    if [[ ! "${CONSENSUS_CLIENT}" =~ "-vc-only.yml" ]]; then
        CL_NODE="http://consensus:5052"

        query_execution_client
        query_rapid_sync
        query_mev
        query_grafana
        query_coinbase
        if [ "${__deployment}" = "node" ]; then
          query_graffiti
        fi
    else
        unset EXECUTION_CLIENT
        unset GRAFANA_CLIENT

        query_remote_beacon
# This gets used, but shellcheck doesn't recognize that
# shellcheck disable=SC2034
        CL_NODE="${REMOTE_BEACON}"
        query_coinbase
        query_graffiti
    fi

    COMPOSE_FILE="${CONSENSUS_CLIENT}"
    if [ -n "${EXECUTION_CLIENT+x}" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:${EXECUTION_CLIENT}"
    fi
    if [ "${__deployment}" = "blox" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:blox-ssv2.yml"
    fi
    if [ -n "${GRAFANA_CLIENT+x}" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:${GRAFANA_CLIENT}"
    fi
    if [ "${MEV_BOOST}" = "true" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:mev-boost.yml"
    fi
    if [ "${NETWORK}" = "goerli" ] || [ "${NETWORK}" = "zhejiang" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:deposit-cli.yml"
    fi
# Not multi-arch, this would break on ARM64
#    COMPOSE_FILE="${COMPOSE_FILE}:ethdo.yml"
    if [ "${__deployment}" = "rocket" ]; then
        COMPOSE_FILE="${COMPOSE_FILE}:ext-network.yml"
        sed -i'.original' -e "s~name: traefik_default~name: rocketpool_net~" ext-network.yml
    fi

    echo "Your COMPOSE_FILE is:" "${COMPOSE_FILE}"

    var=FEE_RECIPIENT
    set_value_in_env
    var=GRAFFITI
    set_value_in_env
    var=CL_NODE
    set_value_in_env
    var=RAPID_SYNC_URL
    set_value_in_env
    var=COMPOSE_FILE
    set_value_in_env
    var=EL_NODE
    set_value_in_env
    var=NETWORK
    set_value_in_env
    var=MEV_BOOST
    set_value_in_env
    var=MEV_RELAYS
    set_value_in_env
    if [[ "${NETWORK}" = "gnosis" ]] && [[ "${CONSENSUS_CLIENT}" =~ "nimbus" ]] ; then
# We are using the variable
# shellcheck disable=SC2034
        NIM_DOCKERFILE=Dockerfile.sourcegnosis
        var=NIM_DOCKERFILE
        set_value_in_env
    fi

    docompose --profile tools build --pull
    exec 3>&1
    exec 4>&2
    exec 1> /dev/null
    exec 2> /dev/null
    docompose pull || true
    exec 1>&3
    exec 2>&4
}

version() {
    # ethd version
    grep "^This is" README.md
    echo ""
    var="COMPOSE_FILE"
    value=$(sed -n -e "s/^${var}=\(.*\)/\1/p" ".env" || true)
    # Client versions
    case "${value}" in
        *blox-ssv2.yml* )
            docompose exec ssv2-node /go/bin/ssvnode --version
            echo
            ;;&
        *lighthouse.yml* | *lighthouse-cl-only* )
            docompose exec consensus lighthouse --version
            echo
            ;;&
        *lighthouse-vc-only* )
            docompose exec validator lighthouse --version
            echo
            ;;&
        *lodestar.yml* | *lodestar-cl-only* )
            docompose exec consensus node /usr/app/node_modules/.bin/lodestar --version
            echo
            ;;&
        *lodestar-vc-only* )
            docompose exec validator node /usr/app/node_modules/.bin/lodestar --version
            echo
            ;;&
        *prysm.yml* )
            docompose exec consensus beacon-chain --version
            echo
            docompose exec validator validator --version
            echo
            ;;&
        *prysm-cl-only* )
            docompose exec consensus beacon-chain --version
            echo
            ;;&
        *prysm-vc-only* )
            docompose exec validator validator --version
            echo
            ;;&
        *nimbus.yml* | *nimbus-cl-only* )
            docompose exec consensus nimbus_beacon_node --version
            echo
            ;;&
        *nimbus-vc-only* )
            docompose exec validator nimbus_validator_client --version
            echo
            ;;&
        *teku.yml* | *teku-cl-only* )
            docompose exec consensus /opt/teku/bin/teku --version
            echo
            ;;&
        *teku-vc-only* )
            docompose exec validator /opt/teku/bin/teku --version
            echo
            ;;&
        *geth.yml* )
            docompose exec execution geth version
            echo
            ;;&
        *reth.yml* )
            docompose exec execution reth --version
            echo
            ;;&
        *besu.yml* )
            docompose exec execution /opt/besu/bin/besu --version
            echo
            ;;&
        *nethermind.yml* )
            docompose exec execution dotnet /nethermind/Nethermind.Runner.dll --version
            echo
            ;;&
        *erigon.yml* )
            docompose exec execution erigon --version
            echo
            ;;&
        *mev-boost.yml* )
            docompose exec mev-boost /app/mev-boost -version
            echo
            ;;&
        *grafana.yml* )
            docompose exec prometheus /bin/prometheus --version
            echo
            echo -n "Grafana "
            docompose exec grafana /run.sh -v
            echo
            ;;&
    esac
}

printhelp() {
    me=$(basename "${BASH_SOURCE[0]}")
    echo "usage: ${me} [help|-h|--help] <subcommand>"
    echo ""
    echo "optional arguments:"
    echo "  help | -h | --help"
    echo "    print this message and exit"
    echo ""
    echo "subcommands:"
    echo "  install"
    echo "     attempts to install docker and docker-compose for you"
    echo "  config"
    echo "     configures eth-docker with your choice of Ethereum clients"
    echo "  keys ACTION"
    echo "     list, delete, import keys; their fee recipients; and gas fees"
    echo "     Run without ACTION to get help text"
    echo "  update [--refresh-targets] "
    echo "     updates all client versions and eth-docker itself"
    echo "     --refresh-targets will reset your custom build targets in .env to defaults"
    echo "  up (or start)"
    echo "     starts the Ethereum node, or restarts containers that had their image or"
    echo "     configuration changed"
    echo "  down (or stop)"
    echo "     stops the Ethereum node"
    echo "  restart"
    echo "     restarts the Ethereum node, a combination of down and up"
    echo "  version"
    echo "     prints the version(s) of currently running client(s)"
    echo "  logs"
    echo "     shows logs"
    echo "  cmd <command>"
    echo "     executes an arbitrary docker compose command. Use \"cmd help\" to list them"
    echo "  terminate"
    echo "     stops the Ethereum node and destroys all data stores"
    echo "  prune-geth"
    echo "     stops the Geth execution client and prunes its DB. This takes about 4-5 hours"
    echo "  prune-nethermind"
    echo "     restarts the Nethermind execution client and prunes its DB."
    echo "  resync-execution"
    echo "     removes the execution layer database and forces a resync."
    echo "  resync-consensus"
    echo "     removes the consensus layer database and forces a resync."
    echo "  attach-geth"
    echo "     launches an interactive geth attach repl"
    echo ""
    echo ""
    echo "The logs subcommand can be appended by flags and specify the container(s). example: "
    echo ""
    echo "  $me logs -f --tail 50 execution"
    echo "    shows logs only for execution service"
    echo ""
    echo "$me will attempt to use sudo as needed for docker commands"
    echo ""
    echo " Give feedback and report issues on GitHub:"
    echo "  * https://github.com/eth-educators/eth-docker"
    echo ""
}

if [[ "$#" -eq 0 || "$1" == "help" || "$1" == "-h" || "$1" == "--help" ]]; then
    printhelp
    exit 0
fi

cd "$(dirname "$(realpath "${BASH_SOURCE[0]}")")"
# Use this to make sure root doesn't end up owning files
if [[ "$OSTYPE" == "darwin"* ]]; then
# This is a macOS-ism
# shellcheck disable=SC2016
    OWNER=$(stat -f '$Su' .)
else
    OWNER=$(stat -c '%U' .)
fi

if [ "${OWNER}" == "root" ]; then
    echo "Please install eth-docker as a non-root user."
    exit 1
fi

ENV_FILE=.env
__during_update=0

command="$1"
shift

determine_distro
handle_root
prep_prometheus

# Don't check for docker before it's installed
if [ "$command" = "install" ]; then
    $command "$@"
    exit "$?"
fi

determine_sudo
determine_docker
determine_compose


if ! type -P whiptail >/dev/null 2>&1; then
    echo "Please install the package whiptail or newt before running this script"
    exit 1
fi

if ! dodocker images >/dev/null 2>&1; then
    echo "Please ensure you can call $__docker_exe before running this script."
    exit 1
fi

if ! docompose --help >/dev/null 2>&1; then
    echo "Please ensure you can call $__compose_exe before running this script"
    exit 1
fi

$command "$@"

__result=$?
if [ "$__result" -eq 127 ]; then
    printhelp
fi

check_disk_space

if [ "${__compose_upgraded}" -eq 1 ]; then
  echo
  echo "You updated compose to V2."
  echo "The \"docker-compose\" command is gone and replaced with \"docker compose\"."
  echo "You can create yourself an alias for \"docker-compose\"."
  echo
  echo "Optionally, you can switch to docker-ce."
  echo "Please see https://eth-docker.net/Usage/Prerequisites#switching-from-dockerio-to-docker-ce for instructions."
elif [ "${__old_compose}" -eq 1 ]; then
  echo
  echo "You are using docker-compose ${__compose_version}, which is unsupported by Docker, Inc. from July 2023 on."
  echo "eth-docker will stop supporting it with Dencun, sometime fall 2023."
  echo ""
  echo "A switch to docker-ce is recommended. It is *not* mandatory. This is unfortunately a manual step that eth-docker cannot do for you."
  echo "Please see https://eth-docker.net/Usage/Prerequisites#switching-from-dockerio-to-docker-ce for instructions."
fi
